<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[卫星模块分工]]></title>
    <url>%2F2020%2F02%2F29%2F%E5%8D%AB%E6%98%9F%E6%A8%A1%E5%9D%97%E5%88%86%E5%B7%A5%2F</url>
    <content type="text"><![CDATA[要实现的功能需要实现一个能绕着地球按指定轨道运行, 可调整俯仰角的卫星, 使其能搭载可控制开关的相机, 相机需要设置角度. 分工 使用TLE数据获得实时的卫星经纬度.这块内容和cesium的关系不大. 但是需要了解两个东西, 第一个是TLE(两行轨道数据), 这里提供两个参考: TLE（两行轨道数据）卫星行李数据格式解析, 卫星轨道和两行数据TLE. 最终的结果是能够做到输入时间, 得到该时间对应的经度, 纬度, 高度(对, 这块是没有姿态角变化的). 如何算, 这里提供三种思路: npm中的sgp4框架: 这个如果可以用应该是最简单的. 这个框架的资料我暂时没找到太多, 需要靠自己找找资料. 但是他参考的是python的sgp4框架, 这个我在项目的www/static/py/TLE2CZML.py中用到了, 我想接口可能不会相差太多. 这是该框架jsdelivr上的网页. github上开源的一个项目: 这个项目说实话我没仔细看, 但是他确实是用js和sgp4实现了经纬度的计算. 问题是项目的文件架构不太明白, 可能doc里面有说明, 如果没有可以试着google看能不能找到解释. 手写: 这个不到万不得已, 还是不要用了, 实在没办法也建议另行google找找其他解决方案, 要是还是不行, 我在网上也找到了一个思路: 请问我有一个卫星的TLE数据，怎么换算成当前时间当前位置的高 创建卫星模型, 使用cesium的clock实现实时改变位置(经度纬度高度), 用浏览器中input的数据使模型的姿态发生变化.这里的卫星模型使用cesium的model来实现. 位置和姿态用modelMartrix来指定. 参考资料可以看cesium-model图元讲解, 该视频以sandcastle中的一个例子简单地介绍了如何创建model, 如何修改model的modelMatrix, 以及一些坐标系转换的方法. 另外也需要先看看第一个视频scene, 对cesium的架构有一个简单的认识. 以上部分属于静态内容. 下面需要实现的是通过cesium的clock实现model的位置变化. 第一个参考是sandcastle中的Time Dynamic Wheels例子, 第二个参考是cesium 实时传参更新模型的位置和姿态, 其他的资料可以在网上找找.在这一小块中, 位置和姿态可自行任意设置, 留出参数存放1中抛出来数据即可. 给定经纬高, 以该点与地心的连线为轴, 创建一个四个侧面顶角都为4.5°的模型. 同时要求该模型可改变位置(方便接下来和卫星的绑定, 这里不要求改变姿态, 也不要求随clock改变).这一块应该要用到Cesium的primitive图元. 这里是视频教程地址: primitive图元的讲解, 另外可以看看groundPrimitive图元, 貌似能实现贴地的效果. 这是一个groundPrimitive的参考, Cesium原理篇：GroundPrimitive.这块的经纬高(卫星的位置)可以自行指定. 此外也看看第一节scene, 便于理解cesium的结构. 补充我们这块用的主要是scene下面的东西, 这块自定义比较强. viewer, entity这块集成度比较高, 自定义方便没这么强. 但实际上呈现出来的效果是没啥差别的. 文档这里给出Cesium1.62的中文文档. 有总比没有强.]]></content>
      <tags>
        <tag>web</tag>
        <tag>cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cesium-primitive图元]]></title>
    <url>%2F2020%2F02%2F29%2FCesium-primitive%E5%9B%BE%E5%85%83%2F</url>
    <content type="text"><![CDATA[primitive可以创建更加灵活的几何体. primitive主要包含两个东西, 一个是GeometryInstance, 另外一个是Appearance. 一个primitive中可以有多个GeometryInstance. 每个GeometryInstance由Geometry控制这个几何体是怎样的种类(box, cylinder之类), 用modelMatrix控制几何体的位置和姿态. 这样就可以实现, 两个GeometryInstance共用一个Geometry, 但是由不同的modelMatrix控制其出现的位置. 多个GeometryInstance因为同属于一个primitive, 所以可以一笔绘制, 性能上是很快的. Appearance指的是物体的表皮. 分为三个部分: Material材质, renderState渲染状态以及materialSupport. 一个比较完整的例子是sandcastle中的Geometry and Appeances以及Materials]]></content>
      <tags>
        <tag>web</tag>
        <tag>cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cesium-影像加载]]></title>
    <url>%2F2020%2F02%2F29%2FCesium-%E5%9C%B0%E5%BD%A2%E5%BD%B1%E5%83%8F%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[影像也是图元的一种. 其层次关系为 Primitives-&gt;Globe-&gt;ImageryLayers. 这部分对应sandcastle中Imagery Layers示例. 影像对应的变量为layers = viewer.scene.imageryLayers. 可以加载很多不同的影像, 即给地球穿上很多不同的表皮. 这里的layers属于Cesium.ImageryLayerCollection类, 具体方法可以查看文档, 包括添加, 删除, 把某个layer的显示层调高或调低等. 可用layers.addImageryProvider()为layers添加数据源. 这样用可以省去创建imageryLayer的过程, 同时返回的是创建的imageryLayer. 一个关于imageryLayers的比较完整的示例是sandcastle中的Imagery Layers Manipulation.]]></content>
      <tags>
        <tag>web</tag>
        <tag>cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap table控件]]></title>
    <url>%2F2020%2F02%2F27%2Fbootstrap-table%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[官方网站 引用这里只介绍使用cdn的方式获取. 在html文件的&lt;head&gt;中包括下面的代码. 12&lt;!-- Latest compiled and minified CSS --&gt;&lt;link rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.16.0/dist/bootstrap-table.min.css"&gt; 在html文件的&lt;/body&gt;前, jquery的js文件之后引入下面的代码. 1234567&lt;!-- Latest compiled and minified JavaScript --&gt;&lt;script src="https://unpkg.com/bootstrap-table@1.16.0/dist/bootstrap-table.min.js"&gt;&lt;/script&gt;&lt;!-- Latest compiled and minified Locales --&gt;&lt;!-- 中国 --&gt;&lt;script src="https://unpkg.com/bootstrap-table@1.16.0/dist/locale/bootstrap-table-zh-CN.min.js"&gt;&lt;/script&gt;&lt;!-- 世界 --&gt;&lt;script src="https://unpkg.com/bootstrap-table@1.16.0/dist/bootstrap-table-locale-all.min.js"&gt;&lt;/script&gt; 使用这里只介绍通过js文件来使用bootstrap table.html文件中需包含: 1&lt;table id="table"&gt;&lt;/table&gt; js文件中可进行的操作(这里只列举常用的操作): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112$('#table').bootstrapTable(&#123; columns: [&#123; filed: 'state', // 在这一列添加选择框 checkbox: true &#125;, &#123; field: 'id', // js文件中用来操作这一列的id title: 'Item ID' // 表格中实际显示的名字 &#125;, &#123; field: 'name', title: 'Item Name' &#125;, &#123; field: 'price', title: 'Item Price' &#125;, &#123; filed: 'operator', // 在最后一栏加上操作栏 title: '操作', formatter: 'operatorFormatter', // 显示内容 event: 'operatorEvents' // 触发事件 &#125;], url: 'data.json', // 使用url获取数据, 在有url获取数据的情况下, data不再起作用 data: [&#123; //数据数组 id: 1, //每一行的数据用键值对表示, key为上面columns中field的值 name: 'Item 1', price: '$1' &#125;, &#123; id: 2, name: 'Item 2', price: '$2' &#125;], pagination: true, // 允许分页 search: true, // 允许搜索 undefinedText: 'N/A', // 未定义数据的显示 showRefresh: true, // 刷新按钮 showToggle: true, // 切换表格的显示形式 (json类型, 表格类型) showFullscreen: true, // 全屏按钮 showColumns: true, // 显示指定列复选框 showColumnsToggleAll: true, // 复选框中多了全选选项 detailView: true, // 每行允许子菜单 showPaginationSwitch: true, // 允许分页按钮 pageList: [10, 25, 50, 100], // 每页显示数据条数 showFooter: true, // 显示表格尾, 需自定义. 参照示例: https://examples.bootstrap-table.com/#options/show-footer.html#view-source classes: 'table table-bordered table-hover table-striped table-dark', // 一些表格的外表设计 customSort: 'customSort', // 自定义排序 method: 'get', // 从服务端获得数据的方式, 默认为get contentType: 'application/json', // 请求头的类型, 默认为application/json dataType: 'json', //希望从服务端返回的数据类型, 默认为json responseHandler: function (res) &#123; //对从服务器返回的数据在加载前进行预处理 return res.data; &#125;, sidePagination: 'server', // 只能填'client'或'server', 默认时'client'. 'server'需要数据前加上total:等字样, 'client'不需要 idField: 'id', // 不明 clickToSelect: true, // 允许点击选中, 有bug virtualScroll: true, // 可以显示非常大的数据量 headerStyle: function headerStyle(column) &#123; // 改变数据表表头的样式, 支持css和classes return &#123; id: &#123; classes: 'uppercase' &#125;, name: &#123; css: &#123; background: 'yellow' &#125; &#125;, price: &#123; css: &#123; color: 'red' &#125; &#125; &#125;[column.field]; &#125;,&#125;);// eslint-disable-next-line no-unused-varsfunction customSort(sortName, sortOrder, data) &#123; const order = sortOrder === 'desc' ? -1 : 1; data.sort(function(a, b) &#123; const aa = +((a[sortName] + '').replace(/[^\d]/g, '')); const bb = +((b[sortName] + '').replace(/[^\d]/g, '')); if (aa &lt; bb) &#123; return order * -1; &#125; if (aa &gt; bb) &#123; return order; &#125; return 0; &#125;);&#125;function operateFormatter(value, row, index) &#123;return [ '&lt;a class="like" href="javascript:void(0)" title="Like"&gt;', '&lt;i class="fa fa-heart"&gt;&lt;/i&gt;', '&lt;/a&gt; ', '&lt;a class="remove" href="javascript:void(0)" title="Remove"&gt;', '&lt;i class="fa fa-trash"&gt;&lt;/i&gt;', '&lt;/a&gt;'].join('')&#125;window.operateEvents = &#123;'click .like': function (e, value, row, index) &#123; alert('You click like action, row: ' + JSON.stringify(row))&#125;,'click .remove': function (e, value, row, index) &#123; $table.bootstrapTable('remove', &#123; field: 'id', values: [row.id] &#125;)&#125;&#125;// 更新表格optionsvar $table = $('#table');$table.bootstrapTable('refreshOptions', &#123; locale: 'zh-CN'&#125;) 常用函数 getSelections remove refresh 更多的函数可以在官网上找到. 一个较为完整的例子这里给出代码的部分解释: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238&lt;link href="https://unpkg.com/bootstrap-table@1.16.0/dist/bootstrap-table.min.css" rel="stylesheet"&gt;&lt;script src="https://unpkg.com/tableexport.jquery.plugin/tableExport.min.js"&gt;&lt;/script&gt;&lt;script src="https://unpkg.com/bootstrap-table@1.16.0/dist/bootstrap-table.min.js"&gt;&lt;/script&gt;&lt;script src="https://unpkg.com/bootstrap-table@1.16.0/dist/bootstrap-table-locale-all.min.js"&gt;&lt;/script&gt;&lt;script src="https://unpkg.com/bootstrap-table@1.16.0/dist/extensions/export/bootstrap-table-export.min.js"&gt;&lt;/script&gt;&lt;style&gt; .select, #locale &#123; width: 100%; &#125; .like &#123; margin-right: 10px; &#125;&lt;/style&gt;&lt;div class="select"&gt; &lt;select class="form-control" id="locale"&gt; &lt;option value="af-ZA"&gt;af-ZA&lt;/option&gt; &lt;option value="ar-SA"&gt;ar-SA&lt;/option&gt; &lt;option value="ca-ES"&gt;ca-ES&lt;/option&gt; &lt;option value="cs-CZ"&gt;cs-CZ&lt;/option&gt; &lt;option value="da-DK"&gt;da-DK&lt;/option&gt; &lt;option value="de-DE"&gt;de-DE&lt;/option&gt; &lt;option value="el-GR"&gt;el-GR&lt;/option&gt; &lt;option value="en-US" selected&gt;en-US&lt;/option&gt; &lt;option value="es-AR"&gt;es-AR&lt;/option&gt; &lt;option value="es-CL"&gt;es-CL&lt;/option&gt; &lt;option value="es-CR"&gt;es-CR&lt;/option&gt; &lt;option value="es-ES"&gt;es-ES&lt;/option&gt; &lt;option value="es-MX"&gt;es-MX&lt;/option&gt; &lt;option value="es-NI"&gt;es-NI&lt;/option&gt; &lt;option value="es-SP"&gt;es-SP&lt;/option&gt; &lt;option value="et-EE"&gt;et-EE&lt;/option&gt; &lt;option value="eu-EU"&gt;eu-EU&lt;/option&gt; &lt;option value="fa-IR"&gt;fa-IR&lt;/option&gt; &lt;option value="fi-FI"&gt;fi-FI&lt;/option&gt; &lt;option value="fr-BE"&gt;fr-BE&lt;/option&gt; &lt;option value="fr-FR"&gt;fr-FR&lt;/option&gt; &lt;option value="he-IL"&gt;he-IL&lt;/option&gt; &lt;option value="hr-HR"&gt;hr-HR&lt;/option&gt; &lt;option value="hu-HU"&gt;hu-HU&lt;/option&gt; &lt;option value="id-ID"&gt;id-ID&lt;/option&gt; &lt;option value="it-IT"&gt;it-IT&lt;/option&gt; &lt;option value="ja-JP"&gt;ja-JP&lt;/option&gt; &lt;option value="ka-GE"&gt;ka-GE&lt;/option&gt; &lt;option value="ko-KR"&gt;ko-KR&lt;/option&gt; &lt;option value="ms-MY"&gt;ms-MY&lt;/option&gt; &lt;option value="nb-NO"&gt;nb-NO&lt;/option&gt; &lt;option value="nl-NL"&gt;nl-NL&lt;/option&gt; &lt;option value="pl-PL"&gt;pl-PL&lt;/option&gt; &lt;option value="pt-BR"&gt;pt-BR&lt;/option&gt; &lt;option value="pt-PT"&gt;pt-PT&lt;/option&gt; &lt;option value="ro-RO"&gt;ro-RO&lt;/option&gt; &lt;option value="ru-RU"&gt;ru-RU&lt;/option&gt; &lt;option value="sk-SK"&gt;sk-SK&lt;/option&gt; &lt;option value="sv-SE"&gt;sv-SE&lt;/option&gt; &lt;option value="th-TH"&gt;th-TH&lt;/option&gt; &lt;option value="tr-TR"&gt;tr-TR&lt;/option&gt; &lt;option value="uk-UA"&gt;uk-UA&lt;/option&gt; &lt;option value="ur-PK"&gt;ur-PK&lt;/option&gt; &lt;option value="uz-Latn-UZ"&gt;uz-Latn-UZ&lt;/option&gt; &lt;option value="vi-VN"&gt;vi-VN&lt;/option&gt; &lt;option value="zh-CN"&gt;zh-CN&lt;/option&gt; &lt;option value="zh-TW"&gt;zh-TW&lt;/option&gt; &lt;/select&gt;&lt;/div&gt;&lt;div id="toolbar"&gt; &lt;button id="remove" class="btn btn-danger" disabled&gt; &lt;i class="glyphicon glyphicon-remove"&gt;&lt;/i&gt; Delete &lt;/button&gt;&lt;/div&gt;&lt;table id="table" data-toolbar="#toolbar" data-search="true" data-show-refresh="true" data-show-toggle="true" data-show-fullscreen="true" data-show-columns="true" data-show-columns-toggle-all="true" data-detail-view="true" data-show-export="true" data-click-to-select="true" data-detail-formatter="detailFormatter" data-minimum-count-columns="2" data-show-pagination-switch="true" data-pagination="true" data-id-field="id" data-page-list="[10, 25, 50, 100, all]" data-show-footer="true" data-side-pagination="server" data-url="https://examples.wenzhixin.net.cn/examples/bootstrap_table/data" data-response-handler="responseHandler"&gt;&lt;/table&gt;&lt;script&gt; var $table = $('#table') var $remove = $('#remove') var selections = [] function getIdSelections() &#123; return $.map($table.bootstrapTable('getSelections'), function (row) &#123; // $.map 是将一个数组(第一个参数) 用一个函数(第二个参数)映射成另一个数组 return row.id &#125;) &#125; function responseHandler(res) &#123; $.each(res.rows, function (i, row) &#123; // 对数组中的每一项做处理 row.state = $.inArray(row.id, selections) !== -1 &#125;) return res &#125; function detailFormatter(index, row) &#123; // 对filed: detail 项作格式化 var html = [] $.each(row, function (key, value) &#123; html.push('&lt;p&gt;&lt;b&gt;' + key + ':&lt;/b&gt; ' + value + '&lt;/p&gt;') &#125;) return html.join('') // join是将数组变为string, 中间用参数隔开 &#125; function operateFormatter(value, row, index) &#123; return [ '&lt;a class="like" href="javascript:void(0)" title="Like"&gt;', '&lt;i class="fa fa-heart"&gt;&lt;/i&gt;', '&lt;/a&gt; ', '&lt;a class="remove" href="javascript:void(0)" title="Remove"&gt;', '&lt;i class="fa fa-trash"&gt;&lt;/i&gt;', '&lt;/a&gt;' ].join('') &#125; window.operateEvents = &#123; 'click .like': function (e, value, row, index) &#123; alert('You click like action, row: ' + JSON.stringify(row)) &#125;, 'click .remove': function (e, value, row, index) &#123; $table.bootstrapTable('remove', &#123; field: 'id', values: [row.id] &#125;) &#125; &#125; function totalTextFormatter(data) &#123; return 'Total' &#125; function totalNameFormatter(data) &#123; return data.length &#125; function totalPriceFormatter(data) &#123; var field = this.field return '$' + data.map(function (row) &#123; return +row[field].substring(1) &#125;).reduce(function (sum, i) &#123; return sum + i &#125;, 0) &#125; function initTable() &#123; $table.bootstrapTable('destroy').bootstrapTable(&#123; height: 550, locale: $('#locale').val(), columns: [ [&#123; field: 'state', checkbox: true, rowspan: 2, // 实现占两行的效果 align: 'center', valign: 'middle' &#125;, &#123; title: 'Item ID', field: 'id', rowspan: 2, align: 'center', valign: 'middle', sortable: true, footerFormatter: totalTextFormatter &#125;, &#123; title: 'Item Detail', colspan: 3, // 实现占三列的效果 align: 'center' &#125;], [&#123; field: 'name', title: 'Item Name', sortable: true, footerFormatter: totalNameFormatter, align: 'center' &#125;, &#123; field: 'price', title: 'Item Price', sortable: true, align: 'center', footerFormatter: totalPriceFormatter &#125;, &#123; field: 'operate', title: 'Item Operate', align: 'center', clickToSelect: false, events: window.operateEvents, formatter: operateFormatter &#125;] ] &#125;) $table.on('check.bs.table uncheck.bs.table ' + 'check-all.bs.table uncheck-all.bs.table', function () &#123; $remove.prop('disabled', !$table.bootstrapTable('getSelections').length) // save your data, here just save the current page selections = getIdSelections() // push or splice the selections if you want to save all data selections &#125;) $table.on('all.bs.table', function (e, name, args) &#123; console.log(name, args) &#125;) $remove.click(function () &#123; var ids = getIdSelections() $table.bootstrapTable('remove', &#123; field: 'id', values: ids &#125;) $remove.prop('disabled', true) &#125;) &#125; $(function() &#123; initTable() $('#locale').change(initTable) &#125;)&lt;/script&gt; 参考表格神器bootstraptableTable Options]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cesium sandcastle中没有Development分组怎么办]]></title>
    <url>%2F2020%2F02%2F27%2FCesium-sandcastle%E4%B8%AD%E6%B2%A1%E6%9C%89Development%E5%88%86%E7%BB%84%E6%80%8E%E4%B9%88%E5%8A%9E%2F</url>
    <content type="text"><![CDATA[从官网下载了编译好的包, 是不能直接使用npm build的. 我在网上找了一些资料, 添加了app/文件夹下的两个文件后可以正常的打包, 但是在sandcastle中却没有出现development分组. 找了资料后发现是只有源码打包后才会出现这个分组. 那么就只能从github上clone到本地, 或者从release中下载源代码到本地. 这样再经过npm build就可以看到development分组了. 此外还有另外几个关于打包的命令可以看参考资料中第二个链接, 可以解决诸如在sandcastle界面无法显示弹出式文档的问题. 参考资料Cesium打包命令Cesium打包命令总结]]></content>
      <tags>
        <tag>web</tag>
        <tag>cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cesium Model图元]]></title>
    <url>%2F2020%2F02%2F27%2FCesium-Model%E5%9B%BE%E5%85%83%2F</url>
    <content type="text"><![CDATA[如何添加model到primitives12345model = scene.primitives.add(Cesium.Model.fromGltf(&#123; url : url, modelMatrix : modelMatrix, minimumPixelSize : 128&#125;)); url位gltf文件的位置, modelMatrix用来控制位置, 姿态等参数. 用var modelMatrix = Cesium.Transforms.headingPitchRollToFixedFrame(origin, hpr);来创建modelMatrix. origin是以地球中心为原点, 以本初子午线与赤道交点方向为x轴, 朝向北极为z轴, y轴根据左手坐标系建系规则建立(大致指向亚洲). 直接求origin是很复杂的, 那么如何简化呢, 用var origin = Cesium.Cartesian3.fromDegrees(-123.0744619, 44.0503706, height);根据经纬度以及高度来确定origin即可, 例子坐标为西经123度, 北纬44度, 高度为height. headingPitchRoll为欧拉角(三个角度用来确定物体的朝向). 初始方向为朝向正东. heading指的是头左右的摆动, pitch指的是头上下摆动, roll则指的是绕视线方向的旋转变换. 初始方向为正朝东方. 如何加载model在创建model对象并加入primitives后, 并不能直接在scene中加载出model对象.model.readyPromise.then()便是异步准备好model对象, 并在then()中执行回调函数. 如何选择12345678var handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);handler.setInputAction(function(movement) &#123; var pick = scene.pick(movement.endPosition); if (Cesium.defined(pick) &amp;&amp; Cesium.defined(pick.node) &amp;&amp; Cesium.defined(pick.mesh)) &#123; // Output glTF node and mesh under the mouse. console.log('node: ' + pick.node.name + '. mesh: ' + pick.mesh.name); &#125;&#125;, Cesium.ScreenSpaceEventType.MOUSE_MOVE); 上述例子实现的是在scene的画布上选择鼠标移动时的点对应的对象, 并进行了简单的判断.]]></content>
      <tags>
        <tag>web</tag>
        <tag>cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CesiumWidget--Scene结构]]></title>
    <url>%2F2020%2F02%2F27%2FCesiumWidget-Scene%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[CesiumWidget内部创建的对象主要有clock, container, canvas, screenSpaceEventHandler, scene几个部分.clock用来记录时间. container则是构造函数的参数, 也就是传入的div. canvas则是在container上构建的Canvas类对象, 可以据此获取WebGL绘制的画笔. screenSpaceEventHandler则是对Canvas对象上各种鼠标的交互事件的封装, 方便传递给三维场景. scene则承载着整个三维场景中的对象. Scene装载了所有的图元(三维对象)Scene中有一些内置的图元对象: golbe(地球), skyBox(天空盒), sun(太阳), moon(月亮)等等. 另外还有两个用来由用户自行控制存放对象的数组: primitives和groundPrimitives(完全贴合地面). 可以将Model对象(gITF), Billboards/Labels/Points, Primitive(包括集合体Geometry和覆盖集合体的外观Appeance), ViewportQuad等添加到primitives中.]]></content>
      <tags>
        <tag>web</tag>
        <tag>cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日期时间选择控件-flatpickr]]></title>
    <url>%2F2020%2F02%2F25%2F%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9%E6%8E%A7%E4%BB%B6-flatpickr%2F</url>
    <content type="text"><![CDATA[项目中需要用到时间选择器, 最开始找到的是bootstrap datetimepicker. 但是出现了几个问题, 一是这个控件虽然支持time显示时分秒, 但是实际上可以选择的最小单位只到了分; 二是time选择器默认是隔五分钟给一个选项, 当然可以修改, 但是也是类似于按钮选择, 不够人性化, 且如果step过小, 比如一分钟, 所显示出来的button就非常多了; 三是该项目已经封存了, 不再更新. 然后经过一番寻找, 找到了这次的主角, flatpickr. 在我初期的使用过程中, 已知的优点有: 支持时分秒的人性化选择. 支持import(这里鞭尸layui, 属实不行) 轻量. 下图说明了使用jQuery UI、Bootstrap、packadate.js和flatpickr拉齐制作一个日期时间选择器时，所需要的文件尺寸大小： 如何开始这里只展示一种, 其他的可以自行上官网查看. 12&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"&gt;&lt;script src="https://cdn.jsdelivr.net/npm/flatpickr"&gt;&lt;/script&gt; 在html文件的&lt;head&gt;中包含这两行. &lt;input class=flatpickr&gt; 如果有jQuery的话, 1$('#id').flatpickr(optional_config); 如果没有, 1flatpickr(element, &#123;optional_config&#125;); 配置这里的配置替代上面的optional_config即可. 配置 类型 说明 enableTime boolean 是否允许输入时和分 enableSeconds boolean 是否允许输入秒 dateFormat string &lt;input&gt;中value的时间的格式 locale string 本地化配置, 具体看这 altInput boolean 是否启用altFormat, 且开启后显示更加贴近原生bootstrap altFormat string &lt;input&gt;中实际显示在网页上的格式 defaultDate Date(), Timestamps, ISO string, Date String, ‘today’ 默认时间, 其中Date String必须和dateFormat相匹配, 可以是仅前n项匹配 minDate 同上 可选择最小时间 maxDate 同上 可选择最大时间 disable array 禁选时间, 每项的类型同上, 另外可以是范围{from:&quot;&quot;, to:&quot;&quot;}, 也可以是函数`function(date){return date.getDay()===0} enable array 与disable相反 mode string ‘multiple’多选, ‘range’范围 conjunction string 多选模式下的分隔符 enableSeconds boolean 是否允许输入秒 time_24hr boolean 是否24小时制 noCalendar boolean 是否不允许日历 inline boolean 默认显示选择框 wrap boolean 是否允许扩展 wrap用法: 1234567891011&lt;div class="flatpickr"&gt; &lt;input type="text" placeholder="Select Date.." data-input&gt; &lt;!-- input is mandatory --&gt; &lt;a class="input-button" title="toggle" data-toggle&gt; &lt;i class="icon-calendar"&gt;&lt;/i&gt; &lt;/a&gt; &lt;a class="input-button" title="clear" data-clear&gt; &lt;i class="icon-close"&gt;&lt;/i&gt; &lt;/a&gt;&lt;/div&gt; 更高端的用法, 例如事件之类的可以上官网去看. 总的来说还是非常不错的, 又好看又好用, 不亏github上12k star.用字符串对日期进行格式化时, 参考文件.]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暗影精灵3 拆机换风扇]]></title>
    <url>%2F2020%2F02%2F22%2F%E6%9A%97%E5%BD%B1%E7%B2%BE%E7%81%B53-%E6%8B%86%E6%9C%BA%E6%8D%A2%E9%A3%8E%E6%89%87%2F</url>
    <content type="text"><![CDATA[cpu风扇出了问题, 一转就巨响. 本来以为是灰太多了, 拆了清灰之后依然响. 看网上说的是要滴油, 感觉太麻烦就淘宝上买了一个风扇装上去. 只记录一下拆机的大致过程, 复原过程反过来即可, 螺丝拆拆装装的时候好像有几个弄混了, 不过装上去能稳就成. 拆电源 拆除图中标注的四颗螺丝, 向上提圈出部分即可. 拆出风口挡板 cpu侧: 显卡侧: 拆完螺丝后, 将挡板往外拔即可. 拆风扇挡板 显卡侧: 这里要注意的是先把四个螺丝拆除, 然后把紫色框中的线拔掉. 这样才能拆除这边的风扇挡板. cpu侧: 风扇挡板这边的螺丝我应该是拍少了, 拆的时候我记得是一边四个一边五个. 总之先拆这几个然后稍微动一下, 看哪个地方动不了就拆哪个地方的螺丝吧. 拆铜管 没啥好说了, 拆掉这八颗螺丝就行. 拆风扇 这里要先拆m.2固态, 然后才能拆风扇. 风扇的螺丝我应该也标少了. 记得拔掉风扇的供电线(紫色框).]]></content>
      <tags>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkjs中的a跳转]]></title>
    <url>%2F2020%2F02%2F17%2Fthinkjs%E4%B8%AD%E7%9A%84%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[假设thinkjs项目下view文件夹的目录为: 12345|--view| |--index_index.html| |--order_index.html| |--order_add.html| |--index_about.html 如果要在index_index.html(url为/)页面跳转到order_index.html页面: &lt;a href=&quot;/order/index.html&gt;, 同时需要在order的controller中添加indexAction()并执行display. 如果要在index_index.html(url为/)页面跳转到index_about.html页面: &lt;a href=&quot;/about.html&gt;, 同样需要配置controller. 总的来说就是要明白thinkjs中的url映射机制.]]></content>
      <tags>
        <tag>web</tag>
        <tag>thinkjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webstorm中静态资源文件夹配置以及eslintrc的配置]]></title>
    <url>%2F2020%2F02%2F11%2Fwebstorm%E4%B8%AD%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%B9%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8Aeslintrc%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[为了解决eslint一部分报错, 需要将配置一下.eslintrc文件: 123456789101112131415&#123; &quot;extends&quot;: &quot;think&quot;, &quot;env&quot;: &#123; &quot;node&quot;: true, &quot;browser&quot;: true, &quot;es6&quot;: true, &quot;jquery&quot;: true &#125;, &quot;rules&quot;: &#123; &quot;no-console&quot;: &quot;off&quot; &#125;, &quot;globals&quot;: &#123; &quot;layui&quot;: true &#125;&#125; 在webstorm中将某个文件夹设为静态资源访问文件夹为, 在webstorm中右键文件夹-&gt;Make directory as-&gt;Resource Root]]></content>
      <tags>
        <tag>web</tag>
        <tag>webstorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于exports和module.exports]]></title>
    <url>%2F2020%2F02%2F09%2F%E5%85%B3%E4%BA%8Enode-js%E4%B8%AD%E7%9A%84exports-module-exports%E5%92%8Cexport-export-default%2F</url>
    <content type="text"><![CDATA[看thinkJS的时候, 里面总有提到这方面, 所以彻底了解一下. 首先, 在使用范围上. require: node支持的引入 export/import: 只有es6支持的导出引入 module.exports/exports: 只有node支持的导出 Node遵循CommonJS规范, CommonJs定义的模块分为: 模块标识(module), 模块定义(exports), 模块引用(require). 在node执行一个文件时, 会给这个文件生成exports和module对象, 而module又有一个exports属性.即exports = module.exports = {};. 1234567891011121314//utils.jslet a = 100;console.log(module.exports); //能打印出结果为：&#123;&#125;console.log(exports); //能打印出结果为：&#123;&#125;exports.a = 200; //这里辛苦劳作帮 module.exports 的内容给改成 &#123;a : 200&#125;exports = '指向其他内存区'; //这里把exports的指向指走//test.jsvar a = require('/utils');console.log(a) // 打印为 &#123;a : 200&#125; 所以说, require导出的内容时module.exports指向的内存块的内容, 而不是exports的. 也就是说, exports只是辅助module.exports操作内存中的数据. 参考资料exports、module.exports 和 export、export default 到底是咋回事]]></content>
      <tags>
        <tag>web</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkJS学习笔记]]></title>
    <url>%2F2020%2F02%2F07%2FThinkJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1. 入门1.1 安装$ npm install -g think-cli 1.2 卸载$ npm uninstall -g thinkjs 1.3 创建项目1234$ thinkjs new demo;$ cd demo;$ npm install; $ npm start; 1.4 项目结构1234567891011121314151617181920212223242526|--- development.js //开发环境下的入口文件|--- nginx.conf //nginx 配置文件|--- package.json|--- pm2.json //pm2 配置文件|--- production.js //生产环境下的入口文件|--- README.md|--- src| |--- bootstrap //启动自动执行目录 | | |--- master.js //Master 进程下自动执行| | |--- worker.js //Worker 进程下自动执行| |--- config //配置文件目录| | |--- adapter.js // adapter 配置文件 | | |--- config.js // 默认配置文件 | | |--- config.production.js //生产环境下的默认配置文件，和 config.js 合并 | | |--- extend.js //extend 配置文件 | | |--- middleware.js //middleware 配置文件 | | |--- router.js //自定义路由配置文件| |--- controller //控制器目录 | | |--- base.js| | |--- index.js| |--- logic //logic 目录| | |--- index.js| |--- model //模型目录| | |--- index.js|--- view //模板目录| |--- index_index.html 2. config/配置ThinkJS将所有的配置都统一管理, 文件都放在src/congig/目录下(多模块项目放在src/common/config/), 并根据不同的功能划分为不同的配置文件. config.js 通用的一些配置 adapter.js adapter 配置 router.js 自定义路由配置 middleware.js middlware 配置 validator.js 数据校验配置 extend.js extend 配置 2.1 多环境配置有些配置需要在不同的环境下配置不同的值，如：数据库的配置在开发环境和生产环境是不一样的，此时可以通过环境下对应不同的配置文件来完成。 多环境配置文件格式为：[name].[env].js，如：config.development.js，config.production.js 在以上的配置文件中，目前只有 config.js 和 adapter.js 是支持不同环境配置文件的。 2.2 使用配置 在 ctx 中, 可以通过ctx.config(key)来获取配置 在controller 中, 可以通过controller.config(key)来获取配置 在其他情况下, 可以通过think.config(key)来获取配置 1234567const redis = ctx.config('redis'); //获取 redis 配置module.exports = class extends think.Controller &#123; indexAction() &#123; const redis = this.config('redis'); // 在 controller 中通过 this.config 获取配置 &#125;&#125; 2.3 动态配置设置1234567// src/bootstrap/worker.js//HTTP 服务启动前执行think.beforeStartServer(async () =&gt; &#123; const config = await think.model('config').select(); think.config('userConfig', config); //从数据库中将配置读取出来，然后设置&#125;) 3. Context/上下文thinkJS的context应该是从koa那边来的. koa Context就是将node的request和response对象封装到单个对象中, 为编写Web应用程序和API提供了许多有用的方法. 这些操作在HTTP服务器中频繁使用. 很多 context 实例的访问器（getter, setter）和方法都是对 Request 和 Response 中属性/方法的简单映射，目的就是为了方便开发。之所以要把这些方法扩展到 context 实例上，而没有做更高层次的封装，目的是为了提高性能，降低在 middleware 中实例中再次实例 Request/Response 的成本。 koa中每个请求都将创建一个context, 并在中间件中作为接收器引用, 或者ctx标识符. Context 是 Koa 中处理用户请求中的一个对象，贯穿整个请求生命周期。一般在 middleware、controller、logic 中使用，简称为 ctx。 4. Middleware/中间件首先要明确一点, 在koa中, 所有关于HTTP请求的事情都是在中间件内部完成的, 最重要的则是理解中间件延续传递的概念. 它的思想是, 一旦中间件完成了它的事情, 它可以选择调用链中的下一个中间件. 4.1 中间件格式12345module.exports = options =&gt; &#123; return (ctx, next) =&gt; &#123; // do something &#125;&#125; 中间件格式为一个高阶函数，外部的函数接收一个 options 参数，这样方便中间件提供一些配置信息，用来开启/关闭一些功能。执行后返回另一个函数，这个函数接收 ctx, next 参数，其中 ctx 为 context 的简写，是当前请求生命周期的一个对象，存储了当前请求的一些相关信息，next 为调用后续的中间件，返回值是 Promise，这样可以很方便的处理后置逻辑。 5. Logic当在 Action 里处理用户的请求时，经常要先获取用户提交过来的数据，然后对其校验，如果校验没问题后才能进行后续的操作；当参数校验完成后，有时候还要进行权限判断等，这些都判断无误后才能进行真正的逻辑处理。如果将这些代码都放在一个 Action 里，势必让 Action 的代码非常复杂且冗长。 为了解决这个问题， ThinkJS 在控制器前面增加了一层 Logic，Logic 里的 Action 和控制器里的 Action 一一对应，系统在调用控制器里的 Action 之前会自动调用 Logic 里的 Action。 Logic 目录在 src/[module]/logic，在项目根目录通过命令 thinkjs controller test 会创建名为 test 的 Controller 同时会自动创建对应的 Logic。若自己手工创建时，Logic 文件名和 Controller 文件名要相同 Logic代码如下: 1234567891011module.exports = class extends think.Logic &#123; __before() &#123; // todo &#125; indexAction() &#123; // todo &#125; __after() &#123; // todo &#125;&#125; 6. Controller/控制器MVC 模型中，控制器是用户请求的逻辑处理部分。比如：将用户相关的操作都放在 user.js 里，每一个操作就是里面一个Action。 可以通过执行命令 thinkjs controller xxx [module]来添加controller，其中xxx为controller名称，而[module]为多模块项目中的项目名称，这时系统将自动完成controller与对应logic文件的创建，并且初始化其内容。 7. View/视图8. Router/路由在 ThinkJS 中，当用户访问一个 URL 时，最后是通过 controller 里具体的 action 来响应的。所以就需要解析出 URL 对应的 controller 和 action，这个解析工作是通过 think-router 模块实现的。 think-router 是一个 middleware，项目创建时默认已经加到配置文件 src/config/middleware.js 里了，其中 options 支持如下的参数： defaultModule {String} 多模块项目下，默认的模块名。默认值为 home defaultController {String} 默认的控制器名，默认值为 index defaultAction {String} 默认的操作名，默认值为 index prefix {Array} 默认去除的 pathname 前缀，默认值为 [] suffix {Array} 默认去除的 pathname 后缀，默认值为 [&#39;.html&#39;] enableDefaultRouter {Boolean} 在不匹配情况下是否使用默认路由解析，默认值为 true optimizeHomepageRouter {Boolean} 是否对首页进行优化，默认值为 true（开启后如果访问地址是首页，那么不会进行自定义路由匹配） subdomainOffset {Number} 子域名映射下的偏移量，默认值为 2 subdomain {Object|Array} 子域名映射列表，默认为 {} denyModules {Array} 多模块项目下，禁止访问的模块列表，默认为 [] 参考资料thinkJS官方文档koa-Context[译] 掌握 Koa 中间件]]></content>
      <tags>
        <tag>web</tag>
        <tag>ThinkJS</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卫星轨道CZML学习笔记]]></title>
    <url>%2F2020%2F02%2F06%2FCesium-CZML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1. 什么是CZMLCZML是一种JSON格式的字符串，用于描述与时间有关的动画场景，CZML包含点、线、地标、模型、和其他的一些图形元素，并指明了这些元素如何随时间而变化。某种程度上说, Cesium 和 CZML的关系就像 Google Earth 和 KML。 2. CZML结构CZML是json的一个子集，也就是说一个有效的CZML文档同时也是一个有效的JSON文档。特别的，一个CZML文档包含一个JSON数组，数组中个每一个对象都是一个CZML数据包（packet），一个packet可以对应一个场景中的对象(例如一个飞机, 一个卫星), 也可以对应其的一部分。 每个packet都拥有一个id属性和若干用来描述地球控件对象的几何位置, 图形外观等的其他CZML属性. 如果一个包的数据量过大(这在描述随事件动态变化的对象时是很常见的), 可将这个地球空间对象的属性信息拆分成多个数据量适中的CZML包, 多个包共用一个id属性. 这种数据组织方式有利于在网络上流式传输时间动态的CZML属性数据. 按照CZML规范的要求, CZML第一个packet仅包含一些必须的文档声明信息, 而不描述具体的地球控件对象. CZML 的一个典型结构如下: 12345678910111213141516171819[ // CZML数据首个packet必须是document对象, 用于文档声明 &#123; "id":"document", "version":"1.0" &#125;, &#123; "id":"myObject1", "property1":"value1", "property2":&#123; "sub-property1":"sub-value1", "sub-property2":"sub-value2" &#125; &#125; &#123; "id":"myObject1" "property3":"value3" &#125;] 3. 动态CZML动态CZML属性的变化分为两种情况: 按时间区间动态变化; 按时间戳动态变化. 12345678910111213141516// 按时间区间动态变化&#123; "id": id, ...// 其他packet属性 "someProperty":[ &#123; "interval":Time interval 1, "propertyValue":Property value 1 &#125;, &#123; "interval":Time interval 2, "propertyValue":Property value 2 &#125;, ...//其他时间区间及对应的属性 ]&#125; 12345678910111213141516171819202122232425// 按时间戳动态变化, 时间戳使用复合ISO8601规范的字符串来定义.&#123; "id": Object id, ...// 其他packet属性 // 并不是所有的属性都能插值 "someInterpolatableProperty": &#123; "epoch": Epoch, //CZML属性动态变化的起始时间 "interpolationAlgorithm": Interpolation algorithm, "interpolationDegree": Interpolation degree, // 对于多个不按时间顺序排列的packet, // 需要用previouTime或nextTime属性规定这些packet在时间上的承接顺序, // 比如可以在当前packet加载完后, // 用nextTime指定下一个要加载的packet所处的时间点 "previousTime": Previous sample time stamp, "nextTime": Next sample time stamp, "sub-property":[ Time stamp 1, Property value 1, Time stamp 2, Property value 2, // 其他的时间戳和属性值 ] &#125;&#125; 4. 加载CZML定义了一个CZML后, 可以将他载入到场景中. 1234dataSource = new Cesium.CzmlDataSource();dataSource.load(czml);//var dataSourcePromise = Cesium.CzmlDataSource.load(czml);viewer.dataSources.add(dataSource); 5. 关于卫星正常运行的人造地球卫星的运动轨迹是一条封闭的曲线. 按照轨道高度可将其分为MEO轨道卫星, GEO轨道卫星和IGSO轨道步卫星. MEO轨道高度位于距离地球表面2000km到35786km之间, 卫星运转周期在2到12小时之间. GEO轨道又叫地球同步卫星轨道, 轨道高度约为36000km. GEO卫星运行方向与地球自转方向相同, 轨道为平行于赤道的近圆形轨道, 运行周期为23h56min4s. 把这种与赤道面交角为零的同步轨道叫做地球静止轨道, 卫星称作静止卫星. IGSO轨道平面与赤道平面夹角不为零, 是一种介于MEO与GEO之间的倾斜同步轨道. 5.1 人造卫星两行轨道根数TLE(Two-line mean element)卫星轨道参数是用来描述卫星轨道的形状, 大小, 轨道平面空间位置, 轨道平面的方向, 以及卫星在轨道上的瞬时位置的一系列参数. 通常包括: 轨道半长轴$\alpha$(semi-major axis) 轨道偏心率$e$(eccentricity, $0\leq e \lt 1$), 椭圆两焦点之间的距离与长轴的比值. 轨道倾角$i$(inclination angle), 是轨道平面和赤道平面的夹角, 取值在$0^\circ ~ 180^\circ$之间 右旋升交点赤经$\Omega$(the right ascension of ascending node, RAAN), 是一个角度值, 表示从卫星春分点开始沿赤道逆时针至上升点的弧长. 卫星近升角距$\omega$(argument of perigee): 从升交点开始沿卫星运行方向至近地点的角距, 也就是近地点与升交点对地心的张角 卫星过近地点时刻$\tau_0$(Epoch of Perigee Passage): 是个时间值, 作为卫星位置随时间变化的初值. 每颗独立的太空人造运动轨迹由两行TLE轨道参数数据描述, 每一行由包括空白字符在内的69个字符组成. 5.1.2 SGP4 模型TLE数据只是提供某颗卫星的轨道参数, 卫星实时状态的测算需要将TLE轨道参数与具体的轨道运算模型或算法结合, 才能得到较为精确的结果. 通常认为TLE结合SGP4模型计算卫星位置和速度是比较可取的, 能得到较高精度的预测结果, 能满足一般地面监控和科研需要. 参考资料cesiumjs开发实践(六) CZMLCesium Language (CZML) 入门1 — CZML Structure（CZML的结构）cesium官方沙盒TLE（两行轨道数据）卫星行李数据格式解析TLE2CZML[1]张彧. 基于Cesium平台的导航卫星轨道模拟与可视化[D].华东师范大学,2017.]]></content>
      <tags>
        <tag>web</tag>
        <tag>CZML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js学习笔记]]></title>
    <url>%2F2020%2F02%2F04%2Fnode-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[nodejs就是运行在服务端的javascript 1. 基本结构 引入required模块. 载入http模块, 并将实例化的http赋值给变量http 1var http = require("http"); 创建服务器 123456789101112131415var http = require('http');http.createServer(function (request, response) &#123;// 发送 HTTP 头部 // HTTP 状态值: 200 : OK// 内容类型: text/plainresponse.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;);// 发送响应数据 "Hello World"response.end('Hello World\n');&#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 2. RERL(Read Eval Print Loop: 交互式解释器)类似于Windows的终端, Linux的Shell. 3. 回调函数 A “callback” is any function that is called by another function which takes the first function as a parameter. Node中所有的API都支持回调函数.一般形式为: 12345678910111213141516171819function foo1(name, age, callback) &#123; &#125;function foo2(value, callback1, callback2) &#123; &#125;var a = 0 function bb(x) &#123; console.log(x)&#125; function timer(time) &#123; setTimeout(function () &#123; a=6 &#125;, time);&#125; //调用:console.log(a)timer(3000)bb(a) 值得注意的是, JS是一种异步执行语言.如这段代码中的bb(a)并不会等待timer()调用完setTimeout()再跳出函数. 这个时候, 用回调函数就能解决这个问题. 12345678910111213141516var a = 0 function bb(x) &#123; console.log(x)&#125; function timer(time, callback) &#123; setTimeout(function () &#123; a = 6 callback(a); &#125;, time);&#125; //调用:console.log(a)timer(3000,bb) 一般而言，函数的形参是指由外往内向函数体传递变量的入口，但此处加了callback后则完全相反，它是指函数体在完成某种使命后调用外部函数的出口！这时候应该明白什么叫”回调”了吧，也就是回头调用外部函数的意思。 3. 事件(EventEmitter类)Node.js所有的异步 I/O 操作在完成时都会发送一个事件到事件队列. 例如: 一个 net.Server 对象会在每次有新连接时触发一个事件, 一个 fs.readStream 对象会在文件被打开的时候触发一个事件. 两个events.EventEmitter()实例: 123456789var events = require('events'); var emitter = new events.EventEmitter(); emitter.on('someEvent', function(arg1, arg2) &#123; console.log('listener1', arg1, arg2); &#125;); emitter.on('someEvent', function(arg1, arg2) &#123; console.log('listener2', arg1, arg2); &#125;); emitter.emit('someEvent', 'arg1 参数', 'arg2 参数'); 123456789101112131415161718192021222324252627282930313233343536373839var events = require('events');var eventEmitter = new events.EventEmitter();// 监听器 #1var listener1 = function listener1() &#123; console.log('监听器 listener1 执行。');&#125;// 监听器 #2var listener2 = function listener2() &#123; console.log('监听器 listener2 执行。');&#125;// 绑定 connection 事件，处理函数为 listener1 eventEmitter.addListener('connection', listener1);// 绑定 connection 事件，处理函数为 listener2eventEmitter.on('connection', listener2);var eventListeners = eventEmitter.listenerCount('connection');console.log(eventListeners + " 个监听器监听连接事件。");// 处理 connection 事件 eventEmitter.emit('connection');// 移除监绑定的 listener1 函数eventEmitter.removeListener('connection', listener1);console.log("listener1 不再受监听。");// 触发连接事件eventEmitter.emit('connection');eventListeners = eventEmitter.listenerCount('connection');console.log(eventListeners + " 个监听器监听连接事件。");console.log("程序执行完毕。");// 特殊事件erroremitter.emit('error'); 4. Bufferjs语言自身只有字符串数据类型, 没有二进制数据类型. Buffer类可创建一个专门存放二进制数据的缓存区. Buffer库为node.js带来了一种存储原始数据的方法, 可以让node.js处理二进制数据. 使用Buffer.from()创建Buffer对象. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 创建一个长度为 10、且用 0 填充的 Buffer。const buf1 = Buffer.alloc(10);// 创建一个长度为 10、且用 0x1 填充的 Buffer。 const buf2 = Buffer.alloc(10, 1);// 创建一个长度为 10、且未初始化的 Buffer。// 这个方法比调用 Buffer.alloc() 更快，// 但返回的 Buffer 实例可能包含旧数据，// 因此需要使用 fill() 或 write() 重写。const buf3 = Buffer.allocUnsafe(10);// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。const buf4 = Buffer.from([1, 2, 3]);// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。const buf5 = Buffer.from('tést');// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。const buf6 = Buffer.from('tést', 'latin1');// 参数描述如下：// string - 写入缓冲区的字符串。// offset - 缓冲区开始写入的索引值，默认为 0 。// length - 写入的字节数，默认为 buffer.length// encoding - 使用的编码。默认为 'utf8' 。// 根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。// 返回值// 返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。buf.write(string[, offset[, length]][, encoding])// 参数// 参数描述如下：// encoding - 使用的编码。默认为 'utf8' 。// start - 指定开始读取的索引位置，默认为 0。// end - 结束位置，默认为缓冲区的末尾。// 返回值// 解码缓冲区数据并使用指定的编码返回字符串。buf.toString([encoding[, start[, end]]])// 合并buffer内容Buffer.concat([buffer1, buffer2,...]) 5. 模块为了让Node.js的文件可以相互调用, Node.js提供了一个简单的模块系统. 12345678//引入当前目录下的hello.js文件var hello = require('./hello');hello.world();//在hello.js文件中, 需要通过exports对象把world作为模块的访问接口exports.world = function() &#123;console.log('Hello World');&#125; 6. 路由接收URL和其他需要的GET及POST参数, 随后根据这些数据来执行相应的代码. 12345678910111213 url.parse(string).query | url.parse(string).pathname | | | | | ------ -------------------http://localhost:8888/start?foo=bar&amp;hello=world --- ----- | | | | querystring.parse(queryString)["foo"] | | querystring.parse(queryString)["hello"] 7. 异步, Promise以及asyc/await首先, 什么是异步. 直观来看, 异步代码的书写顺序与执行顺序不同.(这并不是异步的定义。另外’书写顺序与执行顺序不同的代码’不一定是异步代码)异步意味着不等待任务结束，并没有强制要求两个任务「同时」进行。 12345678910111213//一个异步的例子function taskAsync = function(callback)&#123; var result = setTimeout(function()&#123; callback('异步任务的结果') &#125;, 3000) return result&#125;taskAsync(function callback(result)&#123; console.log(result) // 三秒钟后，这个 callback 函数会被执行&#125;)otherTask() // 立即执行其他任务，不等异步任务结束 那么, 什么是Promise. Promise 是抽象异步处理对象以及对其进行各种操作的组件. 他将一些异步处理对象和处理规则进行规范化, 并按照统一的接口来编写. 采取规定方法之外的写法都会出错. 123456789101112131415// Promise workflowfunction asyncFunction() &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve('Async Hello world'); &#125;, 16); &#125;);&#125;asyncFunction().then(function (value) &#123; console.log(value); // =&gt; 'Async Hello world'&#125;).catch(function (error) &#123; console.log(error);&#125;); asyncFunction 这个函数会返回 promise 对象，对于这个 promise 对象，我们调用它的 then 方法来设置resolve后的回调函数，catch 方法来设置发生错误时的回调函数。 该 promise 对象会在 setTimeout 之后的 16 ms 时被 resolve, 这时 then 的回调函数会被调用，并输出 ‘Async Hello world’ 。 在这种情况下 catch 的回调函数并不会被执行（因为 promise 返回了 resolve），不过如果运行环境没有提供 setTimeout 函数的话，那么上面代码在执行中就会产生异常，在 catch 中设置的回调函数就会被执行。 当然，像 promise.then(onFulfilled, onRejected) 的方法声明一样， 如果不使用catch 方法只使用 then 方法的话，如下所示的代码也能完成相同的工作。 12345asyncFunction().then(function (value) &#123; console.log(value);&#125;, function (error) &#123; console.log(error);&#125;); async 是”异步”的简写, 而 await 可以看作是 async wait 的简写. async 声明的函数返回值是一个 Promise 对象. 在没有 await 的情况下执行 async函数, 它会立即执行, 返回一个 Promise对象, 这和普通返回 Promise对象的函数并无二异. await等待的是一个表达式, 这个表达式的计算结果是Promise对象或者是其他值. 如果它等到的不是一个 Promise 对象, 那 await 表达式的运算结果就是它等到的东西. 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。 单一的 Promise 链并不能发现 async/await 的优势, 但是, 如果需要处理由多个 Promise 组成的 then 链的时候, 优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。 假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 setTimeout 来模拟异步操作： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 传入参数 n，表示这个函数执行的时间（毫秒） * 执行的结果是 n + 200，这个值将用于下一步骤 */function takeLongTime(n) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(n + 200), n); &#125;);&#125;function step1(n) &#123; console.log(`step1 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step2(n) &#123; console.log(`step2 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step3(n) &#123; console.log(`step3 with $&#123;n&#125;`); return takeLongTime(n);&#125;function doIt() &#123; console.time("doIt"); const time1 = 300; step1(time1) .then(time2 =&gt; step2(time2)) .then(time3 =&gt; step3(time3)) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`); console.timeEnd("doIt"); &#125;);&#125;doIt();// step1 with 300// step2 with 500// step3 with 700// result is 900// doIt: 1507.251ms// async/await 实现// 实现的功能一样, 但是显得更加清晰.async function doIt() &#123; console.time("doIt"); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time2); const result = await step3(time3); console.log(`result is $&#123;result&#125;`); console.timeEnd("doIt");&#125; 参考资料Node.js 教程什么是异步？async 函数的含义和用法理解 JavaScript 的 async/await]]></content>
      <tags>
        <tag>web</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Graph Cut实现报告]]></title>
    <url>%2F2020%2F01%2F27%2FGraph-Cut%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1. 方法原理本实验的参考为: Boykov Y Y . Interactive graph cuts for optimal boundary &amp; region segmentation of objects in n-d images[C]// Proc. Eighth IEEE International Conference on Comput. Vis. ICCV 2001. IEEE Computer Society, 2001. 该实验实现了论文中的一个简化版本. 1.1 一些定义 $$A = (A_1, \ldots, A_p, \ldots, A_{|\mathcal{P}|})$$ $p$为图像$\mathcal{P}$上的一个像素点, $\mathcal{|P|}$为像素点的个数, $A$为一个二进制向量, $A_P$的取值为’obj’或’bkg’. 该向量定义了一个分割. $$E(A)=\lambda\cdot R(A) + B(A)$$ where $$R(A)=\sum_{p\in\mathcal{P}} R_p(A_p)$$ $$B(A)=\sum_{\{p,q\}\in\mathcal{N}} B_{\{p,q\}} \cdot \delta(A_p, A_q)$$ $$\delta(A_p, A_q)=\begin{cases} 1, &amp; \text{if $A_p\neq A_q$} \ 0, &amp; \text{otherwise.} \end{cases}$$ $E(A)$为能量函数 $\lambda$指定了区域项(region)属性$R(A)$和边界项(boundary)属性$B(A)$的相对重要性. $\lambda$越大则区域能量在总能量中所占的比重就越大，反之边界能量在总能量中所占比重越大。 $R(A)$给出了对将每个像素$p$赋值为$A_p$(‘obj’或’bkg’)的惩罚, 分别是$R_p(obj&quot;)\; or\; R_p(bkg”)$. 区域能量$R(A)$反映了将每一个像素$p$分割为$A_p$所花费的代价。若像素$p$与用户指定的背景像素越相似，则$R_p(bkg&quot;)$越小；若像素$p$与用户指定的前景像素越相似，则$R_p(obj”)$越小。 $B(A)$为分割$A$的边界能量. $B_{\{p, q\}} \geq 0$是对像素$p$和$q$之间不连续性的惩罚. 通常来说, 当像素$p$和$q$相似时, $B_{\{p, q\}}$很大; 当二者相差很大时, $B_{\{p, q\}}$接近于零. 一般地, 取$B_{\{p,q\}}=e^{-\beta|c_p-c_q|}$, $c_p, c_q$分别是像素$p,q$的颜色. 无向图$\mathcal{G = \langle V, E\rangle}$$$\mathcal{V = P}\bigcup {S,T}$$表示节点(verticals) $$\mathcal{E=N}\bigcup_{p\in\mathcal{P}}\{\{p,S\},\{p,T\}\}$$ 表示边(edges). n-link表示neighborhood links, t-link表示terminal-links. 每一条边 $\mathcal{e \in E}$都有自己的非负权重$w_e$. 我们要找的割是边的一个子集, $C\subset \mathcal{E}$, 使得两个终端被导出子图$\mathcal{G}(C)=\langle\mathcal{V}, \mathcal{E}\backslash C\rangle$所分离. 整个割的cost就是$$|C|=\sum_{e\in C} w_e$$ $\mathcal{O, B\subset P}$, 其分别代表物体像素集合和背景像素集合, $\mathcal{O\bigcap B = \emptyset}$ 下面给出各边的权重表 $$K=1+\max_{p\in\mathcal{P}}\sum_{q:\{p, q\}\in \mathcal{N}} B_{\{p,q\}}$$ 1.2 原理论文中证明, 图$\mathcal{G}$的最小切$\hat{C}$就对应于图像的最优分割, 这里不再赘述. 若${p, S}\in\hat{C}$, 则像素$p$分割为背景; 否则必然有${p, T}\in\hat{C}$, 则像素$p$分割为前景.那么graph cut就转化为了, 已知:$$A_p=\begin{cases} BKG, &amp; \text{if $p\in B$} \ OBJ, &amp; \text{if $p\in O$} \end{cases}$$求$$\min{E(A)=\lambda\cdot R(A) + B(A)}$$并进一步转化为求图的最小割的问题, 可用最大流最小割算法解决. 2. 代码描述2.1 运行环境 操作系统: Microsoft Windows 10专业版 1903 语言: Python 3.7.4 支持库: numpy 1.18.1 opencv-python 4.1.2.30 PyMaxflow 1.2.12 2.2 各模块及功能描述2.2.1 CommandLineMain模块用于用户启动及解析命令行参数的模块, 其中-i -o参数为必须参数, 分别为输入输出的图像地址. 2.2.2 InteractiveUI模块用于处理与用户交互有关的模块, 在原图的窗口上, 用户通过鼠标点击和滑动来选择OBJ_SEEDS和BKG_SEEDS, 按t切换鼠标点击选择的seeds种类, 按c清空现有seeds, 按g利用已选择的seeds对图像进行切割. 在关闭窗口的时候, 会自动保存已经生成的分割后的图像. 2.2.3 GraphBuilder模块 1def add_seed(self, x, y, seg_type) 利用用户在窗口上做的标记, 在全零覆盖seed_overlay加像素. BKG的标注为红色, OBJ的标注为绿色. 1def clear_seeds(self) 初始化前景和背景seeds数组, 以及覆盖seed_overlay. 1def init_graph_value(self) 将用户所添加的seeds转化为graph, 并进行初始化. 前景赋值为OBJ, 背景赋值为BKG. 1def finish_graph(self) 给每个像素一个一维编号, 并添加到nodes[]中, 且将背景连接到T, 前景连到S. 对每个像素(除去最右最下的), 将其与其右像素和下像素添加至edges[], 权重简化为两像素三通道差值平方和的倒数. 1def cut_graph(self) 运用PyMaxflow库, 将已有的图进行转化并求出其最小割, 将切割出来的前景部分标记为紫色. 3. 实验结果原图: 分割后图: 从实验结果上来看, 大致的分割时没有问题的. 但是由于权重取得比较粗糙, 并未像论文中那样, 所以导致边缘部分不够平滑, 且羽毛部分有丢失的情况产生. 用户可以通过现有分割, 适当添加seeds, 来达到分割效果更好的目的.]]></content>
      <tags>
        <tag>DIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode remote development配置]]></title>
    <url>%2F2020%2F01%2F21%2Fvscode-remote-development%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[因为最近需要用ssh在阿里云服务器上远程开发, 所以试一下vscode上的远程开发. 1. 安装扩展vscode安装Remote Development扩展, 剩下的Remote扩展可以自动安装. 2. 配置 安装OpenSSH, 理论上有git就行 1234567891011121314# 检测是否有适合安装的openssh软件Get-WindowsCapability -Online | ? Name -like &apos;OpenSSH*&apos;# 正常情况下返回# Name : OpenSSH.Client~~~~0.0.1.0# State : NotPresent# Name : OpenSSH.Server~~~~0.0.1.0# State : NotPresent# 安装openssh软件Add-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0# 正常情况下返回# Path :# Online : True# RestartNeeded : False Linux上需要安装ssh服务器, 需要支持用户名密码或密钥方式. 先确保用命令行能登录. 然后在vscode的settings.json中添加&quot;remote.SSH.showLoginTerminal&quot;: true 点左下角打开远程窗口按钮, 选择Remote-SSH: Connect to Host... -&gt; C:\Users\用户名\.ssh\config 粘贴下面的代码到打开的config文件, 到这一步就已经可以连接了, 但是要频繁输入密码. 12345Host TargetMachine # 目标机的ip地址 HostName 39.107.13.218 # 目标机的用户名 User root 3. 采用密钥认证避免频繁输入密码 如果之前用过github的ssh认证应该就能在C:\Users\用户名\.ssh里面看到id_rsa.pub文件, 复制一份到linux服务器上的~/.ssh/目录下. 如果之前没有使用过github的ssh认证, 在C:\Users\用户名\.ssh文件夹下打开powershell, 输入ssh-keygen, 一路回车下去, 就得到了这个文件. 把本地的id_rsa.pub文件复制到远端的~/.ssh下, 在该目录下执行cat id_rsa.pub &gt;&gt; authorized_keys, 实际上就是把内容加进去. 参考资料VSCode远程编辑,Remote-SSH,Remote Development VSCode Remote ssh跳板机配置（windows平台）]]></content>
      <tags>
        <tag>vscode</tag>
        <tag>remote development</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript学习笔记]]></title>
    <url>%2F2020%2F01%2F20%2Fjavascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这里只列出js与其他编程语言不一样的地方, 一样的则不再赘述. 对象方法 123456var object = &#123; method: function() &#123; &#125;&#125; 给尚未声明的变量赋值, 该变量自动作为window的一个属性. 1234567891011121314151617181920var var1 = 1; // 不可配置全局属性var2 = 2; // 没有使用 var 声明，可配置全局属性console.log(this.var1); // 1console.log(window.var1); // 1delete var1; // false 无法删除console.log(var1); //1delete var2; console.log(delete var2); // trueconsole.log(var2); // 已经删除 报错变量未定义//---------------carname是全局变量-----------// 此处可调用 carName 变量 function myFunction() &#123; carName = "Volvo"; // 此处可调用 carName 变量&#125; 返回对象名 123var x = 'abc';var y = new String("john");typeof x;l 相等switch中的case采用的是===s 1234//绝对相等var x = &quot;a&quot;;var y = new String(&quot;a&quot;);(x===y) //结果为false, 绝对相等属性和类型都要相等 js标签 1234567891011121314// label:// statementscars=["BMW","Volvo","Saab","Ford"];list: &#123; document.write(cars[0] + "&lt;br&gt;"); document.write(cars[1] + "&lt;br&gt;"); document.write(cars[2] + "&lt;br&gt;"); break list; document.write(cars[3] + "&lt;br&gt;"); document.write(cars[4] + "&lt;br&gt;"); document.write(cars[5] + "&lt;br&gt;"); &#125; null与undefined 12345678910111213var person = null; // 值为 null(空), 但类型为对象var person = undefined; // 值为 undefined, 类型为 undefinedvar person; // 值为 undefined(空), 类型是undefinedperson = undefined; // 值为 undefined, 类型是undefined//值相等但是类型不相等typeof undefined // undefinedtypeof null // objectnull === undefined // falsenull == undefined // true//先检测undefined, 再检测nullif (typeof myObj !== "undefined" &amp;&amp; myObj !== null) 正则表达式/正则表达式主题/修饰符(可选)修饰符: i: 执行对大小写不敏感的匹配. g: 执行全局匹配 m: 执行多行匹配 变量提升函数声明和变量声明总是会被解释器悄悄地被”提升”到方法体的最顶部。JavaScript 只有声明的变量会提升，初始化的不会。 严格模式不允许使用未声明的变量, 不允许删除变量或对象, 不允许删除函数, 不允许变量重名, 不允许使用八进制, 不允许使用转义字符, 不允许对只读属性赋值, 不允许对一个使用getter方法读取的属性进行复制, 不允许删除一个不允许删除的属性, 变量名不能用”eval”, “arguments”, 不允许this指向全局对象 1"use strict" //只在作用域内有效 表单验证 123456789function validateForm() &#123; var x = document.forms["myForm"]["fname"].value; if (x == null || x == "") &#123; alert("需要输入名字。"); return false; &#125;&#125;//可以用在onsubmit中 letlet声明的变量只在let命令所在的代码块内有效. javascript:void(0)void()代表不返回任何值, 但是括号里面的表达式还是会进行 内嵌函数与闭包 (解决计数器困境)所有函数都能访问全局变量。实际上，在 JavaScript 中，所有函数都能访问它们上一层的作用域。JavaScript 支持嵌套函数。嵌套函数可以访问上一层的函数变量。 12345678910111213141516var add =function () &#123; var counter = 0; window.alert("父方法"); // 只有在 add 赋值时执行一次 return function () &#123; window.alert("子方法"); // 每次执行 add() 都会执行 return counter += 1; &#125; // counter 作用域在父函数中, 自然在其子函数中也能使用,但因为 // 子函数还需要使用了count, 所以 count 不随着父函数一起释放。 // 利用在 function()&#123;&#125;() 的形式自动执行一遍父匿名函数, 赋给 add 子方法。&#125;();function myFunction()&#123; document.getElementById("demo").innerHTML = add(); //这里add()执行的就是子方法&#125; JavaScript HTML DOM(Document Object Model)EventListener, 监听事件.addEventListener() 方法添加的事件句柄不会覆盖已存在的事件句柄。可以向一个元素添加多个事件句柄。可以向同个元素添加多个同类型的事件句柄，如：两个 “click” 事件。可以向任何 DOM 对象添加事件监听，不仅仅是 HTML 元素。如： window 对象。addEventListener() 方法可以更简单的控制事件（冒泡与捕获）。当使用 addEventListener() 方法时, JavaScript 从 HTML 标记中分离开来，可读性更强， 在没有控制HTML标记时也可以添加事件监听。可以使用 removeEventListener() 方法来移除事件的监听。 事件冒泡或事件捕获事件传递有两种方式：冒泡与捕获。事件传递定义了元素事件触发的顺序。 如果你将 元素插入到 元素中，用户点击 元素, 哪个元素的 “click” 事件先被触发呢？在冒泡中，内部元素的事件会先被触发，然后再触发外部元素，即： 元素的点击事件先触发，然后会触发 元素的点击事件。在捕获中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即： 元素的点击事件先触发 ，然后再触发 元素的点击事件。addEventListener() 方法可以指定 “useCapture” 参数来设置传递类型：false为冒泡传递, true为捕获传递. BOM浏览器对象模型(Browser Objdect Model) Window对象表示浏览器窗口, 包括HTML DOM的document也是window对象的属性之一: window.document.getElementById(&quot;header&quot;)计时事件 1234window.setInterval(function, milliseconds)window.clearInterval(intervalVariable)window.setTimeout(function, milliseconds)window.clearTimeout(timeoutVariable) CookieCookie用于存储web页面的用户信息.Cookie以键值对的形式存储, username = John Doe1234567891011121314151617181920212223242526272829303132function setCookie(cname,cvalue,exdays)&#123; var d = new Date(); d.setTime(d.getTime()+(exdays*24*60*60*1000)); var expires = "expires="+d.toGMTString(); document.cookie = cname + "=" + cvalue + "; " + expires;&#125;function getCookie(cname)&#123; var name = cname + "="; var ca = document.cookie.split(';'); for(var i=0; i&lt;ca.length; i++) &#123; var c = ca[i].trim(); if (c.indexOf(name)==0) return c.substring(name.length,c.length); &#125; return "";&#125;function checkCookie()&#123; var user=getCookie("username"); if (user!="")&#123; alert("欢迎 " + user + " 再次访问"); &#125; else &#123; user = prompt("请输入你的名字:",""); if (user!="" &amp;&amp; user!=null)&#123; setCookie("username",user,30); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CO 汉明码]]></title>
    <url>%2F2019%2F10%2F26%2FCO-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E5%8F%8A%E6%A3%80%E9%94%99%E7%BA%A0%E9%94%99%2F</url>
    <content type="text"><![CDATA[假定有一个长为k位的数据, 要另外添加r个校验位来保证k+r中任何一个数据位出错时, 将影响r个校验位中不同的校验位组合起变化, 此外还需要一个组合来反映正确的情况. 故位数r和k的关系为:$$2^r\geq k+r+1$$汉明码的码距(即从一个合法码变成另一个合法码至少要改变几位码的值)为4. 可以发现并改正一位错, 能发现两位错(但不能改正). 如何为各校验位分配数据位组合(假定$k=3,r=4$):$$P1(1), P2(2), D1(3), P3(4), D2(5), D3(6), P4$$ 看数据位编号分别为3, 5, 6, 他们均可表示为校验位编号的组合: $$3=1+2, 5=1+4, 6=2+4$$ 1出现在3和5中, 则校验位P1需要对D1和D2进行校验. 2出现在3和6中, 则校验位P2需要对D1和D3进行校验. 4出现在5和6中, 则校验位P3需要对D2和D3进行校验. 最后用其他各校验位及各数据位进行异或运算求P4的值, 用于区分无错, 奇数位错, 偶数位错三种情况.$\mathrm{P4=P3\bigoplus P2\bigoplus P1\bigoplus D3\bigoplus D2\bigoplus D1}$]]></content>
      <tags>
        <tag>Notes</tag>
        <tag>Computer Organization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章 引论]]></title>
    <url>%2F2019%2F10%2F10%2F%E7%AC%AC1%E7%AB%A0-%E5%BC%95%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[用户与操作系统交互的程序, 基于文本的通常称为shell, 而基于图标的则称为图形用户界面(Graphical User Interface), 它们实际上并不是操作系统的一部分. 多数计算机有两种运行模式: 内核态和用户态. 软件中最基础的部分是操作系统, 它运行在内核态(也称为管态, 核心态). 在内核态中, 操作系统具有对所有硬件的完全访问权, 可以执行机器能够运行的任何指令. 软件的其余部分运行再用户态下. 在用户态下, 只使用了机器指令的一个子集. 用户接口程序(shell或者GUI)处于用户态程序中的最低层次, 允许用户运行其他程序(Web浏览器等). 操作系统运行再裸机之上, 为所有其他软件提供基础的运行环境. 什么是操作系统操作系统有两个基本上独立的任务, 即为应用程序员(实际上是应用程序)提供一个资源集的清晰抽象, 并管理这些硬件资源. 下面逐项进行讨论操作系统的功能. 作为扩展机器的操作系统多数计算机的体系结构(指令集, 存储组织, I/O和总线结构)是很原始的, 而且编程时很困难的. 操作系统的任务就是创建好的抽象, 并实现和管理它所创建的抽象对象. 作为资源管理者的操作系统自顶向下地看, 操作系统向应用程序提供基本抽象. 按照自底向上的观点, 操作系统则用来管理一个复杂系统的各个部分, 其任务是在相互竞争的程序之间有序地控制对处理器, 存储器以及其他I/O接口设备的分配. 资源管理包括用一下两种不同方式实现多路复用(共享)资源: 在时间上复用和在控件上复用.]]></content>
      <categories>
        <category>Modern Operating System</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中秋]]></title>
    <url>%2F2019%2F09%2F13%2F%E4%B8%AD%E7%A7%8B%2F</url>
    <content type="text"><![CDATA[现在是2019年中秋最开始的一个小时. 四个小时前, 我, H和Z说趁着小学期结束去喝两杯. 我想记录下来, 希望五年或者十年后还能记得这几个王八蛋酒友. 我和Z君上学期倒是有出来喝过, 最开始在酒吧, 凌晨十二点半, 酒吧许是看着没啥生意, 说要打烊了. 于是我和Z君提着两打燕京在学服门口喝到五点, 期间还绕着学校走了一圈, 最后把阿姨叫醒放我们回去睡大觉, 现在想起来还觉得怪不好意思. 说起Z君, 虽说一直也相处得挺好, 不过倒是第一次约出来作酒友. 说老实话, Z君和H君那些关于爱情的往事我基本上也知道得八九不离十, 都有过那么些个不堪回首的经历. 总的来说, Z君是痴情男儿, 对远在土澳的那个人念念不忘(或许现在已经慢慢释然), 按他自己的话来说已经无力再爱; H君前几天刚与心结say goodbye, 嘴上说着已经释怀, 但我总觉着还得过一阵子; 而我自己, 早就说过不敢再奢望, 但即使不用看的, 也能嗅到来源于她的特殊味道. 兄弟少年, 都是那么贱兮兮的. 说起未来, Z君已经联系好导师, 不出意外应该能保上本校的研究生(我觉得Z君应该有更好的出路, 不过这也是后话了). H君和我准备着实习, 大四毕业找工作. 我们谈着至少也得在北京这座城市里奋斗那么五年十年, 还约好谁发文章, 谁拿工资得请请吃饭, 对未来既充满了踌躇有满怀期望, 虽然矛盾但却是当下最真实的想法, 毕竟已经过了大一最迷茫的时刻. 明天, 不, 今天就是中秋节了. 想起初中高中那会儿, 中秋节还会到湘江边上, 要么到茶摊蹭大人们点的菊花茶, 要么从小贩那买一盏孔明灯点上, 让它承载着我的期望, 随风而去. 离家千万里的现在, 幸好还有亲人在. 不出意外, 十二个小时后应该会和姐姐出去吃顿饭, 说起来, 我们上半年基本没怎么见过, 尽管就在同一个城市. 或许是因为北京城太大, 或许是因为我们之间的差异太大. 另外妈妈也会过来, 该用什么样的心情去面对呢? 随机应变吧, 这事不值得费脑子. 晚安.]]></content>
      <tags>
        <tag>随便聊聊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-09]]></title>
    <url>%2F2019%2F09%2F05%2F2019-09%2F</url>
    <content type="text"><![CDATA[九月份已经过去五天了, 之前因为小学期的关系, 没时间腾出来想一想这个月该干的事情. 先回顾一下上个月. 说好的看计算机网络的内容, 实际上还是摸鱼了, 只看了第一章. (要是没有摸鱼, 说不定小学期就不会过得这么艰难了, 哭) 算法和数据结构以及LeetCode的题感觉完成度有个50%? 嘛, 反正这是一个长期项目, 每个月根据所看的内容写个几十道困难题, 我觉得也还行. 然后到了九月份的计划.先暂时列一个书单吧: 计算机网络自顶向下方法 现代操作系统 算法(S&amp;W) 汇编语言 如果有英文版本就中英对照着看, 不过为了能快速阅读, 还是以中文版本为主吧.]]></content>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小学期即时聊天软件后]]></title>
    <url>%2F2019%2F09%2F05%2F%E5%B0%8F%E5%AD%A6%E6%9C%9F%E5%8D%B3%E6%97%B6%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6%E5%90%8E%2F</url>
    <content type="text"><![CDATA[记录一下在做完小学期聊天软件项目之后, 得到的一些感触. 学习能力方面仍然欠缺太多。 在没有接触过多线程和网络编程的情况下去，我发现我学习socket编程的速度确实过慢。导致后来放弃做网络通信模块，转而做数据库模块。好在有之前数据库知识的储备，虽然也是第一次用mysql，但是无论是上手还是设计接口都来得得心应手。这算是比较满意的一个部分。 设计对于程序的重要性甚至超过编码。 就我个人编写的数据库模块而言，在我第一天初步设计好所有数据库供服务端调用的接口之后，我和吴大伟在第二天实现接口时，几乎是一气呵成，其中还包括了各个接口的简单测试。而且第一天实现好了接口，也方便服务端先调用空的接口，实现大致的代码框架。 团队合作能力的重要性。 在项目的最开始，我们便决定了使用github托管项目进行版本控制，但由于基本上大家之前要么没用过git，要么只用github托管过个人项目，不需要团队合作，也就不会有那么多的代码冲突。在我们实际的项目进行中，虽然这种情况不常见，但还是出现了版本诸如回退之后删除了本地未提交文件等错误。再就是合码真的是一个累活，既要保证自己的代码不出现问题，还要保证别人在调用的时候传入正确的参数，最后还需要自己编写的模块能使整个项目正常运转，我们合码的时间确实是过晚了，如果能重来的话，我想我会选择写一部分合一部分测一部分，而不是各个模块先分工，最后大家每个模块都完成得差不多了再进行代码的整合。 英语能力的欠缺。 对于一般的库来说，中文文档基本不能保证是最新的版本，且代码质量和代码风格也得不到保证，机翻又会导致有些专有词汇错翻。倒不是说看不懂英文文档，只是看英文文档时速度实在是太慢，只适合于看看某个函数的大致功能是啥，传入啥参数什么的。除开文档外，想要得到一些优质的问题解决方案，StackOverflow是必不可少的，基本对我来说，上StackOverflow最多看看回答者的回答，而回答下面的跟答就很少看了，总的来说还是英文能力太弱了。]]></content>
      <tags>
        <tag>随便聊聊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell命令基础]]></title>
    <url>%2F2019%2F08%2F27%2Fshell%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[小学期需要在linux环境下完成即使通讯软件, 因此需要懂一点shell的基础知识. 随手做笔记~希望里面不要出现纰漏. Base&lt;用户名&gt;@&lt;主机名&gt;:~(用户主目录, 即/home/&lt;用户名&gt;)$(#代表root用户)命令基本格式 command [option] [arguments] 查询操作:man info –help Command ls -a 显示所有 -l 详细信息 -X 按扩展名的字典序排列 -x 按行 -C 按列 -d 本目录 ls &gt; a.txt &gt; 为重定向符 即将ls得到的结果写入a.txt mvmv [1] [2]文件改名文件移到目标文件夹下文件夹移到目标文件夹下文件夹改名 cpcp [文件] [目录]cp -a [目录] [目录] (所有属性都不变)cp -r [目录] [目录] (递归拷贝, 不保留文件属性(例如文件创建时间)) mkdirmkdir -p [目录] 嵌套创建目录mkdir -m&lt;权限&gt; [目录] 权限设置例如: mkdir -m777 dir, 在当前目录下创建了一个权限为777, 文件名为dir的目录 rmrm [文件]rm -r [目录] filefile [目标文件或目录] 确定文件类型 cat/tac -n 显示行号 cat [文件1] [文件2] 合并之后展示, 不生成新的文件 cat [文件1] [文件2] &gt; [文件3] 将文件1,2合并后写入文件3 touchtouch [文件名] 创建文件 ln -s 软链接: 类似于快捷方式, 用于指向原来的文件. 删除软连接, 不影响原来的文件; 删除原文件, 软连接则不可再使用 硬链接: 默认创建硬链接, 相当于原文件的一个别名, 实际上是同一个文件. 举个栗子: 创建a.txt, 写入hello, 为a.txt创建软链接s.txt和硬链接r.txt, 删除a.txt, s.txt无法使用, r.txt仍然是hello, 重新创建a.txt, 写入world, 此时s.txt内容为world, r.txt仍为hello. 可见, 软链接靠文件名访问. tar(打包和压缩不是同一个概念) -c 创建tar文件 -f 将文件打包生成到一个文件里 如:tar -cf new.tar /home/junqi -x 对tar进行解包 tar -xf new.tar .bz2和.gz的区别: 1. .bz2比.gz压缩率更高 2. .gz比.bz2花费更少的时间 针对zip格式: 1. 打包 tar cvzf &lt;文件名&gt;.gz &lt;目录&gt; 将目录下的文件打包并压缩 2. 解包 tar xvzf &lt;文件名&gt;.gz 解压到当前目录; tar xvzf &lt;文件名&gt;.gz -C &lt;目录&gt; 解包到制定的目录下 针对biz2: 1. 打包 tar cvjf &lt;文件名&gt;.biz2 &lt;目录&gt; 将目录下的文件打包并压缩 2. 解包 tar xvjf &lt;文件名&gt;.biz2 解压到当前目录; tar xvjf &lt;文件名&gt;.biz2 -C &lt;目录&gt; 解包到制定的目录下]]></content>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#316 去除重复字母]]></title>
    <url>%2F2019%2F08%2F24%2FLeetCode-316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D%2F</url>
    <content type="text"><![CDATA[题面解:思路:总的想法是, 尽量让字典序小的字母靠前出现. 对于字符串cbacdcbc进行遍历, 在已经选择的串为c的情况下考虑第二个字母b, 因为后面仍然有c, 且b的字典序比c小, 删掉现有的c并将b加入选择的串, 这样得到的结果更优(同一个位置字典序小的字母占优, 不论后面的字母如何变幻). 第三个字母同理. 遍历到第四个和第五个字母时, 字典序呈升序, 直接加入结果仍然最优. 遍历第六个字母c时, 因为选择结果中已经出现过c, 所以不做处理(如果需要做处理, 那么就要删除已选择的元素直到至少把之前的那个c删除才能保证字典序不变大. 如果恰好删除到之前的c, 再加入现在的c, 这样的操作就毫无意义. 如果删除了更之前的, 即类似将a替换成了c, 仍然使字典序变大了). 再到b, 未出现过, 直接加入. 用StringBuilder代替栈, 方便最后转成字符串. 算法: 初始化int[] count数组, 初始化boolean[] used数组, 初始化存放结果的StringBuilder resSb和LinkedList resList 遍历一遍字符串, 记录每个字母出现的次数, count[s.charAt(i) - &#39;a&#39;]++ 遍历字符串, char letter作为当前字符, i为当前索引值. count[letter - &#39;a&#39;]-- 如果当前字符已经出现在sb中, 即used[letter - &#39;a&#39;] == true, continue. 当已选择的字串不为空resList.size() &gt; 0, 该字符的字典序小于栈顶的字符letter &lt; resList.getLast(), 且栈顶字符在字符串的后面仍然会出现count[resList.getLast() - &#39;a&#39;] &gt; 0 更新used[resList.getLast() - &#39;a&#39;] = false 弹出栈顶, resList.removeLast() 循环 添加当前字母, resList.addLast(letter), used[letter - &#39;a&#39;] = true. 遍历resList, 依次添加入resSb, 返回resSb.toString()代码:1234567891011121314151617181920212223242526272829public String removeDuplicateLetters(String s) &#123; int[] count = new int[26]; boolean[] used = new boolean[26]; StringBuilder resSb = new StringBuilder(); LinkedList&lt;Character&gt; resList = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; count[s.charAt(i) - 'a']++; &#125; char letter; for (int i = 0; i &lt; s.length(); i++) &#123; letter = s.charAt(i); count[letter - 'a']--; if (used[letter - 'a']) &#123; continue; &#125; while (resList.size() &gt; 0 &amp;&amp; letter &lt; resList.getLast() &amp;&amp; count[resList.getLast() - 'a'] &gt; 0) &#123; used[resList.getLast() - 'a'] = false; resList.removeLast(); &#125; resList.addLast(letter); used[letter - 'a'] = true; &#125; for (Character character : resList) &#123; resSb.append(character); &#125; return resSb.toString();&#125; 复杂度: 执行用时 内存消耗 语言 12ms(51.42%) 35.7MB(66.07%) Java 时间复杂度 $ O(n) $ 空间复杂度 $ O(n) $]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#232 用栈实现队列]]></title>
    <url>%2F2019%2F08%2F24%2FLeetCode-232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题面两个栈实现:思路:用一个栈作为队列尾, 另一个栈作为队列头. 形如: 算法: 入队直接压入rear 出队如果front不为空直接出front栈顶, 如果front为空, 将rear元素全部转移到front再出front栈顶. 为空判断两个栈是否都为空 队首与出队类似 代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MyQueue &#123; Stack&lt;Integer&gt; front; Stack&lt;Integer&gt; rear; /** Initialize your data structure here. */ public MyQueue() &#123; front = new Stack&lt;&gt;(); rear = new Stack&lt;&gt;(); &#125; /** Push element x to the back of queue. */ public void push(int x) &#123; rear.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ public int pop() &#123; if (empty()) &#123; throw new RuntimeException("QueueEmpty"); &#125; if (front.empty()) &#123; while (!rear.empty()) &#123; front.push(rear.pop()); &#125; &#125; return front.pop(); &#125; /** Get the front element. */ public int peek() &#123; if (empty()) &#123; throw new RuntimeException("QueueEmpty"); &#125; if (front.empty()) &#123; while (!rear.empty()) &#123; front.push(rear.pop()); &#125; &#125; return front.peek(); &#125; /** Returns whether the queue is empty. */ public boolean empty() &#123; return front.empty() &amp;&amp; rear.empty(); &#125;&#125; 复杂度: 执行用时 内存消耗 语言 83ms(90.67%) 35MB(43.88%) Java 时间复杂度: 分摊下来为$ O(1) $, 对于任意$n$个元素的入队和出队来说, 其操作总次数都不会超过$4n$次, 即每个元素都入队列且都出队(相当于每个元素都入rear栈, 出rear栈, 进front栈, 再出front栈). 但对于某一次的出队操作来说, 其时间复杂度会出现$ O(n) $的情况. 空间复杂度 $ O(n) $, 需要两个栈存元素.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#85 最大矩形]]></title>
    <url>%2F2019%2F08%2F20%2FLeetCode-85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[题面运用栈:思路:为方便讨论, 假定矩阵的层数从上往下依次递增. 假定最大矩形的底边在第n层, 对于第n层中为”0”的那些列, 对最大矩形无贡献. 对于第n层中为”1”的那些列, 最大矩形的高度为某一个”1”往上的连续个”1”之和. 遍历矩阵的层, 对每层按LeetCode#84 柱状图中最大的矩形的算法求出对应的面积. 要求的最大面积为这n层所求面积中最大的那个. 算法: 初始化高度数组heights[matrix.length][matrix[0].length], maxArea = 0 按层遍历matrix, 对于矩阵的每层, 更新相应的heights[i][] 按照LeetCode#84 柱状图中最大的矩形中的算法传入高度数组, 更新maxArea 代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445public int maximalRectangle(char[][] matrix) &#123; if (matrix == null || matrix.length == 0) &#123; return 0; &#125; int maxArea = 0; int[][] heights = new int[matrix.length][matrix[0].length]; for (int i = 0; i &lt; heights.length; i++) &#123; for (int j = 0; j &lt; heights[0].length; j++) &#123; if (i == 0) &#123; heights[i][j] = matrix[i][j] == '0' ? 0 : 1; &#125; else &#123; heights[i][j] = matrix[i][j] == '0' ? 0 : heights[i - 1][j] + 1; &#125; &#125; &#125; for (int[] height : heights) &#123; maxArea = Math.max(maxArea, maxHistogramRectangle(height)); &#125; return maxArea; &#125;static private int maxHistogramRectangle(int[] heights) &#123; int maxArea = 0; Stack&lt;Integer&gt; heightsIndexStack = new Stack&lt;&gt;(); heightsIndexStack.push(-1); for (int i = 0; i &lt; heights.length; i++) &#123; while (heightsIndexStack.peek() != -1 &amp;&amp; heights[i] &lt;= heights[heightsIndexStack.peek()]) &#123; int mid = heightsIndexStack.pop(); int width = i - heightsIndexStack.peek() - 1; maxArea = Math.max(maxArea, heights[mid] * width); &#125; heightsIndexStack.push(i); &#125; while (heightsIndexStack.peek() != -1) &#123; int mid = heightsIndexStack.pop(); int width = heights.length - heightsIndexStack.peek() - 1; maxArea = Math.max(maxArea, heights[mid] * width); &#125; return maxArea;&#125; 复杂度: 执行用时 内存消耗 语言 54ms(27.98%) 49.3MB(45.00%) Java 假定矩阵为$ m \times n $矩阵 时间复杂度 $ O(m*n) $, 计算heights[][]需要$ O(m * n) $; 遍历层数, 对每层求最大面积需要$ O(m * n) $. 空间复杂度 $ O(m*n) $, 存放高度的heights[][]需要$ O(m * n) $; 栈需要$ O(n) $.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#84 柱状图中最大的矩形]]></title>
    <url>%2F2019%2F08%2F19%2FLeetCode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[题面 暴力解:思路:对于每个出现的柱子高度, 找到该高度对应的最大面积.对于高度2, 1, 5, 6, 2, 3, 出现了1, 2, 3, 5, 6五个高度. 我们只需遍历一遍这五个高度, 找出每个高度对应的连续的高大于等于该高度的柱子数即可. 算法: 创建HashSet, 对高度进行去重. 以height遍历HashSet中每一个高度 初始化maxWidth = 0, width = 0 遍历原柱子数组 如果当前高度大于height, width++. 否则, maxWidth = Math.max(maxWidth, width), width = 0. 再次更新maxWidth, 以比较最后一串连续的柱子宽和maxWidth. 更新最大面积maxArea 代码:12345678910111213141516171819202122232425static public int largestRectangleArea(int[] heights) &#123; int maxArea = 0; HashSet&lt;Integer&gt; heightSet = new HashSet&lt;&gt;(); for (int height : heights) &#123; heightSet.add(height); &#125; for (Integer height : heightSet) &#123; int maxWidth = 0; int width = 0; for (int currentHeight : heights) &#123; if (currentHeight &gt;= height) &#123; width++; &#125; else &#123; maxWidth = Math.max(maxWidth, width); width = 0; &#125; &#125; maxWidth = Math.max(maxWidth, width); maxArea = Math.max(maxArea, maxWidth * height); &#125; return maxArea;&#125; 复杂度: 执行用时 内存消耗 语言 708ms(18.85%) 44.3MB(20.35%) Java 时间复杂度 $ O(n^2) $, 最坏情况, 当所有柱子高度都不同, 且依次递增时, 内外循环次数都为n 空间复杂度 $ O(n) $, HashSet占用额外$ O(n) $ 空间复杂度为$ O(n^2) $时, 会爆内存. 应用单调栈思路:遍历每个柱子, 对每个柱子而言, 他所能达到的最大面积为, 最小高度为该柱子的高度, 宽度最宽的矩形. 即对于每个柱子, 要找到他左右两边第一个小于他的柱子, 中间形成的矩形的面积便是该柱子所能达到的最大面积. 这样的思路和LeetCode#42 接雨水就很像了, 考虑运用单调栈解决问题. 考虑一排递增的柱子, 每个柱子的左边第一个便是第一个小于他的柱子. 我们用栈来维护这样一个递增的序列. 遍历所有柱子, 如果当前柱子的高度大于等于栈顶柱子的高度, 则直接压栈; 否则, 当前柱子便是现在的栈顶柱子的右边第一个小于他的柱子, 将当前柱子记作right, 弹出栈顶元素记作mid, 弹出后的新栈顶便是mid左边第一个小于他的柱子, 记作left, 这样便可以求出以heights[mid]为高度, 介于left和right之间的矩形面积最大值. 算法: 初始化栈heightIndexStack, 压入-1(索引-1可作为任意右边柱子的左边界); 初始化最大面积maxArea = 0 遍历所有柱子, 当前遍历到的柱子索引记作current 如果栈不为空(即栈顶元素不为-1)且当前柱子的高度小于等于栈顶柱子的高度(如果去掉等于, 假定一组高度为1, 1, 2, 2, 1, 那么当读到最后一个1时, 栈内为-1, 0, 1, 2, 3, 显然当索引3作为中间值的时候, 索引2并不能成为其左边界). 弹出栈顶元素, 记作mid 以heights[mid]为高度的最大矩形区域的宽为width = current - heightIndexStack.peek() - 1 更新maxArea = Math.max(maxArea, heights[mid] * width) 将当前柱子索引压栈 若此时栈仍然不为空(即栈顶元素不为-1), 相当于current移动到heights.length的位置, 继续更新maxArea直到栈空代码:1234567891011121314151617181920212223242526static public int largestRectangleArea(int[] heights) &#123; if (heights == null || heights.length == 0) &#123; return 0; &#125; int maxArea = 0; Stack&lt;Integer&gt; heightIndexStack = new Stack&lt;&gt;(); heightIndexStack.push(-1); for (int current = 0; current &lt; heights.length; current++) &#123; while (heightIndexStack.peek() != -1 &amp;&amp; heights[current] &lt;= heights[heightIndexStack.peek()]) &#123; int mid = heightIndexStack.pop(); int width = current - heightIndexStack.peek() - 1; maxArea = Math.max(maxArea, width * heights[mid]); &#125; heightIndexStack.push(current); &#125; while (heightIndexStack.peek() != -1) &#123; int mid = heightIndexStack.pop(); int width = heights.length - heightIndexStack.peek() - 1; maxArea = Math.max(maxArea, width * heights[mid]); &#125; return maxArea;&#125; 复杂度: 执行用时 内存消耗 语言 44ms(42.76%) 43.1MB(34.64%) Java 时间复杂度 $ O(n) $, 每个元素入栈出栈两次操作. 空间复杂度 $ O(n) $, 栈需要额外的$ O(n) $空间.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Stack</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#42 接雨水]]></title>
    <url>%2F2019%2F08%2F17%2FLeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[题面 暴力解:思路:对于每个元素, 其能达到的最大高度为该元素左边所有元素中的最大值和右边所有元素中的最大值其中较小的那一个. 算法: 初始化res为0 便利整个height数组 初始化 leftMax = height[left], rightMax = height[right] 从当前元素向左扫描并更新leftMax 从当前元素向右扫描并更新rightMax 当左右最大元素值均比当前元素值大时, res += Math.min(leftMax, rightMax) - height[i]; 代码:1234567891011121314151617181920212223242526static public int trap(int[] height) &#123; int res = 0; for (int i = 1; i &lt; height.length - 1; i++) &#123; int left = i - 1, right = i + 1; int leftMax = height[left]; int rightMax = height[right]; while (left &gt;= 0) &#123; if (leftMax &lt; height[left]) &#123; leftMax = height[left]; &#125; left--; &#125; while (right &lt;= height.length - 1) &#123; if (rightMax &lt; height[right]) &#123; rightMax = height[right]; &#125; right++; &#125; if (height[i] &lt; leftMax &amp;&amp; height[i] &lt; rightMax) &#123; res += Math.min(leftMax, rightMax) - height[i]; &#125; &#125; return res;&#125; 复杂度: 执行用时 内存消耗 语言 152ms(5.4%) 42MB(60.13%) Java 时间复杂度 $ O(n) $, 对于每个元素, 都要从扫描整个数组 空间复杂度 $ O(1) $ 应用栈:思路:遍历数组时, 用栈来追踪可能储水的长条或作为”墙”的长条. 储水长条和”墙”长条的概念是相对的, 可以变动. 有水坑的必要条件是当前扫描到的长条作为”墙”长条, 栈中至少有一个储水长条和一个”墙”长条, 这样即可填平”一层”(“一层”的高可能超过1, 这里指的是一层或多层宽度相同的方块条叠起来). 层层填平后, 当前位置之前的所有水坑已填平(当作后面已经没有长条). 当前长条将作为新的储水长条或”墙”长条压入栈. 当前长条的高度小于栈顶高度时, 将当前长条压入栈.当前长条的高度大于或等于栈顶长条的高度时, 层层填平两个长条中间的部分, 并将当前长条压入栈. 算法: 使用栈stack来保存长条的索引 遍历数组 当栈不为空且当前元素的高度大于或等于栈顶元素的高度 弹出栈顶元素topIndex. 若栈为空(意味着之前的坑全部填平, 且无论怎么填后面的坑都不会对之前的坑有影响), 跳出循环. 计算要填的”一层”坑的宽度: trapWidth = current - stack.peek() - 1, 高度: trapHeight = Math.min(height[current], height[stack.peek()]) - height(topIndex). 填坑, res += trapWidth * trapHeight. 重复以上操作. 将当前元素压入栈 图示: 代码:123456789101112131415161718static public int trap(int[] height) &#123; int res = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int current = 0; current &lt; height.length; current++) &#123; while (!stack.empty() &amp;&amp; height[current] &gt;= height[stack.peek()]) &#123; int topIndex = stack.pop(); if (stack.empty()) &#123; break; &#125; int trapWidth = current - stack.peek() - 1; int trapHeight = Math.min(height[current], height[stack.peek()]) - height[topIndex]; res += trapWidth * trapHeight; &#125; stack.push(current); &#125; return res;&#125; 复杂度: 执行用时 内存消耗 语言 15ms(19.33%) 37.1MB(85.67%) Java 时间复杂度 $ O(n) $, 每个条形快最多访问两次, 即压入和弹出操作$ O(1) $. 空间复杂度 $ O(n) $, 栈最多占用$ O(n) $的空间]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Homework Problems and Questions Chapter1]]></title>
    <url>%2F2019%2F08%2F11%2FHomework-Problems-and-Questions-Chapter1%2F</url>
    <content type="text"><![CDATA[Review QuestionsSECTION 1.1 没有区别; 手机, PC, iPad, 服务器, 智能家居终端; 算. A protocol is a rule which describes how an activity should be performed, especially in the field of diplomacy. In diplomatic services and governmental fields of endeavor protocols are often unwritten guidelines. Protocols specify the proper and generally accepted behavior in matters of state and diplomacy. 开发者可以根据协议标准开发可以互相通信的网络系统, 标准不同则无法通信. SECTION 1.2 Class Access Technologies Home Access DSL Internet Access, Cable Internet Access, FTTH, Satellite access, Dial-up access, WiFi Enterprise Access 100 Mbps Ethernet, WiFi. Wide-area Wireless Access 3G, 4G, 5G HFC 带宽是用户间共享的. 下行通道是共享的, 每个分组由单一的头端发送向下行径每段链路到每个家庭, 藉由分布式多路访问协议可避免碰撞. Access Technologies Upstream Rate Downstream Rate Monthly Price FTTH 20 Mbps 200 Mbps 60元 4G 7.72 Mbps 38.2 Mbps 17元 使用以太网接入, 用户通常以100Mbps速率接入以太网交换机, 而服务器可能具有1Gbps甚至10Gbps的接入速率. 绝大部分是双绞铜线, 也能运行在光纤上. Access Technologies Transmission Rates Bandwidth DSL 55 Mbps downstream and 15 Mbps upstream dedicated HFC up to 42.8 Mbps downstream and 30.7 Mbps upstream shared FTTH 2-10 Mbps upload; 10-20 Mbps download shared Dial up 56 kbps dedicated WiFi 和 4G 技术:a) 在无线LAN环境中, 无线用户必须位于接入点几十米范围内发送或接收分组. 传输速率高达54Mbps. 接入点一般连接着有线因特网, 将无线用户接入有线网络.b) 分组通过蜂窝网提供商运营的基站来发送和接受, 一个用户只需位于基站的数万米内. SECTION 1.3 0时刻发送主机开始发送, $ t_1 = L / R_1 $ 时刻发送主机完成发送, 由于没有传播时延, 同时刻整个分组被路由器接收, 并同时由路由器开始发送向接收主机. $ t_2 = t_1 + L / R_2 $时刻, 路由器发送完分组, 整个分组被接收主机接收. 所以端对端时延为$ L / R_1 + L / R_2 $. 电路交换网络在端系统通信会话期间, 预留了端系统间通信沿路径所需的资源(缓存, 链路传输速率). 绝大部分的分组交换网络不能保证端对端通信的带宽. 频分复用需要复杂的模拟硬件来讲信号转换到合适的频带. a. $ 2 / 1 = 1 $b. 在发送时, 每个用户需要1 Mbps, 如果两个或更少的用户同时传输, 最多需要2 Mbps. 共享链路的带宽是2 Mbps, 所以不会有排队时延. 当有3个及以上的用户同时发送时, 他们需要3 Mbps或更多, 带宽无法满足, 于是存在排队时延.c. $ 0.2 $d. 三个用户同时发送数据的概率为 $ 0.2^3 $, 只有当三个用户同时发送数据时, 队列才会增长, 故队列增长的时间比例也是 $ 0.2^3 $. 如果同等级的ISP不对等的话, 相互通信则需要向提供商ISP支付流量成本. IXP可以向连接着他的ISP收取费用. 谷歌的专用网络连接起了它所有的数据中心. 谷歌的数据中心之间的流量通过其专用网络传输, 而不是公共因特网. 谷歌的数据中心直接与低级别的ISP连接, 所以当谷歌向用户提供内容时, 可以绕过更高级别的ISP; 首先, 因为它使用很少的中间ISP, 所以内容提供商可以提供更好的用户体验. 其次, 它可以向提供商网络发送更少的流量节省费用. SECTION 1.4 处理时延, 排队时延, 传输时延, 传播时延. 除了排队时延, 其他的都是确定的. Transmission vs Propagation Delaya. $1000km, 10^8m/s, 1Mbps, 100Bytes$b. $10km, 2.9\times10^8m/s, 1Mbps, 100Bytes$ $t = \frac{2500km}{2.5\cdot10^8m/s} = 10ms$, $ d/s $, no, no. a. 500 kbpsb. 64sc. 320s 如何生成分组: 将文件分块 在每个块前加上header形成分组 每个分组包含目的地的IP地址 分组交换器如何将分组转发到对应的链路: 分组交换其识别分组中的IP地址来确定转发的链路. 比喻: 车比作分组, 拿着目的地地址问路比作分组交换器识别分组中的IP地址并转发分组到相应的链路. Queuing and Loss最大的发送速率: 200 packets/minute最小的传输速率: 1 packets/minute流量强度为200当发送的过程相同时, 两次的初始丢包时间相同. SECTION 1.5 error control, flow control, segmentation and reassembly, multiplexing, and connection setup; yes. the application layer, the transport layer, the network layer, the link layer, the physical layer.Principal responsibilities:Application layer: HTTP, SMTP, and FTP protocols are used in application layer. it is used to send data over multiple end systems. Transport layer: Transfer the content between two endpoints mainly. TCP and UDP protocols are used in transport layer. Network layer: Move the packets between any two hosts in the network. IP protocol is used in network layer. Data link layer: Move the packets from one node to the next another node. Point-to-point protocol (ppp) used in data link layer. Physical layer: Transfer the individual bits from one node to the next node with in the frame. 应用层报文: 应用程序想要发送并传递到传输层的数据运输层报文段: 封装了应用层应用层报文和传输层标头网络层数据报: 封装了运输层报文段和网络层标头链路层帧: 封装了网络层数据报和链路层标头 网络层, 链路层, 物理层; 链路层, 物理层; 五层都处理 SECTION 1.6 病毒需要与人交互才能传播. 蠕虫可以自己扫描IP地址和端口号, 寻找可以注入的进程 创造僵尸网络: 攻击者寻找有漏洞的主机系统 用木马破坏主机系统用于DDoS: 僵尸网络中的任何系统都可以利用漏洞自动扫描环境并传播 创造僵尸网络的人可以远程控制僵尸网络中的所有节点 攻击者可以命令僵尸网络中的所有节点向某个节点攻击 Problems]]></content>
      <categories>
        <category>Computer Networking A Top-Down Approach(7th Edition) RQ&amp;P</category>
      </categories>
      <tags>
        <tag>Computer Networks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter1 Computer Networks and the Internet]]></title>
    <url>%2F2019%2F08%2F04%2FChapter1-Computer-Networks-and-the-Internet%2F</url>
    <content type="text"><![CDATA[What Is the InternetA Nuts-and-Bolts DescriptionThe Internet is a computer network that interconnects billions of computing devices throughout the world. All of these devices are called hosts or end systems. End systems are connected together by a network of communication links and packet switches. Transmission rate is measured in bits/second. When one end system has data to send to another end system, the sending end system segments the data and adds header bytes to each segment. The resulting packages of information is known as packets. The two most prominent types in today’s Internet are routers and link-layer switches. The sequence of communication links and packet switches traversed by a packet from the sending end system to the receiving end system is known as a route or path through the network. End systems access the Internet through Internet Service Providers (ISPs). Protocols control the sending and receiving of information within the Internet. The Transmission Control Protocol(TCP) and the Internet Control Protocol(TCP) are two of the most important protocols in the Internet. Internet standards are developed by the Internet Engineering Task Force(IETF). The IETF standards documents are called request for comments(RFCs). A Services DescriptionThe applications that Internet provides services to are said to be distributed applications, since they involve multiple end systems that exchange data with each other. Socket interface specifies how a program running on one end system asks the Internet infrastructure to deliver data to a specific destination program running on another end system. What Is a Protocol?A protocol defines the format and the order of messages exchanged between two or more communicating entities, as well as the actions taken on the transmission and/or receipt of a message or other event. The Network EdgeHosts are sometimes further divided into two categories: clients and servers. Access Networks The access network is the network that physically connects and end system to the first router(also known as the “edge router”). Home AccessToday, the two most prevalent types of broadband residential access are digital subscriber line(DSL) and cable. For the DSL Internet access, the residential telephone line carries both data and traditional telephone signals simultaneously, which are encoded at different frequencies: A high-speed downstream channel, in the 50 kHz to 1 MHz band A medium-speed upstream channel, in the 4 kHz to 50 kHz band An ordinary two-way telephone channel, in the 0 to 4 kHz band The DSL standards define multiple transmission rates, including 55 Mbps downstream and 15 Mbps upstream[ITU 2006]. The access is said to be asymmetric. One important characteristic of cable Internet access is that it is a shared broadcast medium. In particular, every packet sent by the head end travels downstream on every link to every home and every packet sent by a home travels on the upstream channel to the head end. While DSL makes use of telco’s existing local telephone infrastructure, cable Internet access makes use of the cable television company’s existing cable television infrastructure. The cable Internet access is typically asymmetric, with downstream channel typically allocated a higher transmission rate than the upstream channel. The DOCSIS 2.0 standard defines downstream rates up to 42.8 Mbps and upstream rates of up to 30.7 Mbps. An up-and-coming technology that provides even higher speeds is fiber to the home(FTTH). The FTTP concept is simple–provide an optical fiber path from the CO directly to the home. This image shows FTTH using the passive optical network(PON) distribution architecture. Each home has an optical network terminator(ONT), which is connected by dedicated optical fiber to a neighborhood splitter. The splitter combines a number of homes onto a single, shared optical fiber, which connects to an optical line terminator(OLT) in the telco’s CO. The OLT, providing conversion between optical and electrical signals, connects to the Internet via a teleco router. In locations where DSL, cable, and FTTH are not available, a satellite link can be used to connect a residence to the Internet at speeds of more than 1 Mbps. Dial-up access over traditional phone lines is based on the same model as DSL–a home modem connects over a phone line to a modem in the ISP. Dial-up access is excruciatingly slow at 56 kbps. Access in the Enterprise (and the Home): Ethernet and WiFi On corporate and university campuses, and increasingly in home settings, a local area network(LAN) is used to connect an end system to the edge router. Ethernet is by far the most prevalent access technology in many types of LAN technologies. With Ethernet access, users typically have 100 Mbps or 1 Gbps access to the Ethernet switch, whereas servers may have 1 Gbps or even 10 Gbps access. Wireless LAN access based on IEEE 802.11 technology, more colloquially known as WiFi, is now everywhere. 802.11 today provides a shared transmission rate of up to more than 100 Mbps. Wide-Area Wireless Access: 3G and LTEDevices like smartphones employ the same wireless infrastructure used for cellular telephony to send/receive packets through a base station that is operated by the cellular network provider. Physical MediaFor each transmitter-receiver pair, a bit is sent by propagating electromagnetic waves or optical pulses across a physical medium. Physical medium fall into two categories: guided media and unguided media. With guided media, the waves are guided along a solid medium, such as a fiber-optic cable, a twisted-pair copper wire, or a coaxial cable. With unguided media, the waves propagate in the atmosphere and in outer space, such as in a wireless LAN or a digital satellite channel. Twisted-Pair Copper WireThe least expensive and most commonly used guided transmission medium. Unshielded twisted pair(UTP) is commonly used for computer networks within a building, that is, for LANs. Data rates for LANs using twisted pair today range from 10 Mbps to 10 Gbps, which depend on the thickness of the wire and the distance between transmitter and receiver. Coaxial CableLike twisted pair coaxial cable consists of two copper conductors, but the two conductors are concentric rather than parallel, which can make coaxial cable achieve high data transmission rates. Coaxial cable can be used as a guided shared medium. Fiber OpticsAn optical fiber is a thin, flexible medium that conducts pulses of light, with each pulse representing a bit. A single optical fiber can support tremendous bit rates, up to tens of even hundreds of gigabits per second. They are immune to electromagnetic interference. Terrestrial Radio ChannelsThey require no physical wire to be installed. Satellite Radio ChannelsThe communication satellite receives transmissions on one frequency band, regenerates the signal using a repeater, and transmits the signal on another frequency. The Network Core Packet SwitchingIn a network application, end systems exchange messages with each other.To send message from a source end system to a destination end system, the source breaks long messages into smaller chunks of data known as packets. Between source and destination, each packet travels through communication links and packet switches(two predominant types, routers and link-layer switches). Store-and-Forward TransmissionMost packet switches use store-and-forward transmission at the inputs to the links. It means that the packet switch must receive the entire packet before it can begin to transmit the first bit of the packet onto the outbound link. Queuing Delays and Packet LossEach packet switch has multiple links attached to it. For each attached link, the packet switch has an output buffer(also called an output queue), which stores packets that the router is about to send into the link. Due to this, packets suffer output buffer queuing delays. When an arriving packet find that the buffer is completely full with other packets waiting for transmission, packet loss will occur–either the arriving packet or one of the already-queued packets will be dropped. Forwarding Tables and Routing ProtocolsIn the Internet, every end system has an address called an IP address. A packet source includes the destination’s IP address in the packet’s header. Each router has a forwarding table that maps destination addresses(or portions of the destination addresses) to that router’s outbound links. The Internet has a number of special routing protocols that are used to automatically set the forwarding tables. A routing protocol may, for example, determine the shortest path from each router to each destination and use the shortest path results to configure the forwarding tables in the routers. Circuit SwitchingThere are two fundamental approaches to moving data through a network of links and switches: circuit switching and packet switching. In circuit-switched networks, the resources(buffers, link transmission rate) needed along a path to provide for communication between the end systems are reserved for the duration of the communication session between the end systems. In packet-switched networks, these resources are not reserved. Consider the traditional telephone networks, the network must establish a connection between the sender and the receiver. The switches on the path between the sender and receiver maintain connection state for that connection. This connection is called a circuit. Multiplexing in Circuit-Switched NetworksA circuit in a link is implemented with either frequency-division multiplexing(FDM) or time-division multiplexing(TDM). With FDM, the frequency spectrum of a link is divided up among the connections established across the link. The link dedicates a frequency band to each connection for the duration of the connection. The width of the band is called bandwidth. For a TDM link, time is divided into frames of fixed duration, and each frame is divided into a fixed number of time slots. These slots are dedicated for the sole use of that connection. Packet Switching Versus Circuit SwitchingPacket switching has end-to-end delays is variable and unpredictable.(due primarily to variable and unpredictable queuing delays) But it offers better sharing of transmission capacity than circuit switching and it is simpler, more efficient, and less costly to implement than circuit switching. Circuit switching pre-allocates use of the transmission link regardless of demand, with allocated but unneeded link time going unused. Packet switching on the other hand allocates link use on demand. A Network of NetworksBy creating a network of networks, the puzzle, the access ISPs themselves must be interconnected is completed. A points of presence(PoP) is simply group of one or more routers(at the same location) in the provider’s network where customer ISPs can connect into the provider IPS. PoPs exist in all levels of the hierarchy, except for the bottom(access ISP) level. For a customer network to connect to a provider’s PoP, it can lease a high-speed link from a third-party telecommunications provider to directly connect one of its routers to a router at the PoP. Any ISP(except for tier-1 ISPs) may choose to multi-home, that is, to connect to two or more provider ISPs. To reduce the costs that a customer ISP pays a provider ISP for amount of traffic, a pair of nearby ISPs at the same level of the hierarchy can peer. They can directly connect their networks together so that all the traffic between them passes over the direct connection rather than through upstream intermediaries. Along these same lines, a third-party company can create an Internet Exchange Point(IXP), which is a meeting point where multiple ISPs can peer together. Content provider, like Google, can created its own networks and connect directly into lower-tier ISPs(settlement free) where possible. Delay, Loss, and Throughput in Packet-Switched Networks.Computer networks necessarily constrain throughput(the amount of data per second that can be transferred) between end systems, introduce delays between end systems, and can actually lose packets. Overview of Delay in Packet-Switched NetworksThe most important delays are the nodal processing delay, queuing delay, transmission delay, and propagation delay; together, these delays accumulate to give a total nodal delay. Processing DelayThe time required to examine the packet’s header and determine where to direct the packet is part of the processing delay. Processing delays in the high-speed routers are typically on the order of microseconds or less. Queuing DelayAt the queue, the packet experiences a queuing delay as it waits to be transmitted onto the link. Queuing delays can be on the order of microseconds to milliseconds in practice. Transmission DelayDenote the length of the packet by $ L $ bits, and denote the transmission rate of the link from router A to router B by $ R $ bits/sec. The transmission delay is $ L/R $. This is the amount of time required to push(that is, transmit) all of the packet’s bits into the link. Transmission delays are typically on the order of microseconds to milliseconds in practice. Propagation DelayOnce a bit is pushed into the link, it needs to propagate to router B. The time required to propagate from the beginning of the link to router B is the propagation delay. The propagation speed depends on the physical medium of the link(that is, fiber optics, twisted-pair copper wire, and so on) and is in the range of $ 2 \times 10^8 $ meters/sec to $ 3 \times 10^8 $ meters/sec. The propagation delay is the distance between two routers divided by the propagation speed. In wide-area networks, propagation delays are on the order of milliseconds. Comparing Transmission and Propagation DelayThe transmission delay is the amount of time required for the router to push out the packet; it has nothing to do with the distance between the two routers. The propagation delay is the time it takes a bit to propagate from one router to the next; it is a function of the distance between the two routers, but has nothing to do with the packet’s length or the transmission rate of the link. Queuing Delay and Packet LossThe most complicated and interesting component of nodal delay is the queuing delay. The rate at which traffic arrives at the queue, the transmission rate of the link, and the nature of the arriving traffic, that is whether the traffic arrives periodically or arrives in bursts, impacts the queuing delay. Let $ a $ packets/sec denote the average rate at which packets arrive at the queue. $ R $ bits/sec is the transmission rate. All packets consist of $ L $ bits. Then the average rate at which bits arrive at the queue is $ La $ bits/sec. The ratio $ La/R $, called traffic intensity, often plays an important role in estimating the extent of the queuing delay. One of the golden rules in traffic engineering is: Design your system so that the traffic intensity is no greater than 1. Consider the case $ La/R \leq 1 $. Here, the nature of the arriving traffic impacts the queuing delay. Typically, the arrival process to a queue is random. Packet LossIn reality a queue preceding a link has finite capacity. Packet delays do not really approach infinity as the traffic intensity approaches 1. Instead, a packet can arrive to find a full queue. With no place to store such a packet, a router will drop the packet; that is, the packet will be lost. Therefore, performance at a node is often measured not only in terms of delay, but also in terms of the probability of packet loss. End-to-End delaySuppose there are $ N-1 $ routers between the source host and the destination host. $ d_{proc} $ is the processing delay at each router and at the source host. The transmission rate out of each router and out of the source host is $ R $ bits/sec, and the propagation on each link is $ d_{prop} $. The nodal delays accumulate and give an end-to-end delay, $$ d_{end-end} = N(d_{proc} + d_{trans} + d_{prop}) $$, where, $ d_{trans} = L/R $, where $ L $ is the packet size. Throughput in Computer NetworksIn addition to delay and packet loss, another critical performance measure in computer networks is end-to-end throughput. The instantaneous throughput at any instant of time is the rate (in bits/sec) at which Host B is receiving the file from Host A. For some applications, including those involving file transfers, delay is not critical, but it is desirable to have the highest possible throughput. The constraining factor for throughput in today’s Internet is typically the access network because the core of the Internet is over-provisioned with high speed links that experience little congestion. When there is no other intervening traffic, the throughput for a file transfer is the transmission rate of the bottleneck link along the path between server and client. More generally, the throughput depends not only on the transmission rates of the links along the path, but also on the intervening traffic. Protocol Layers and Their Service ModelsFor organizing a network architecture, or at least our discussion of network architecture. Layered ArchitectureEach layer provides its service by (1) performing certain actions within that layer and by (2) using the services of the layer directly below it. For large and complex systems that constantly being updated, the ability to change the implementation of a service without affecting other components of the system is another important advantage of layering. Protocol LayeringTo provide structure to the design of network protocols, network designers organize protocols–and the network hardware and software that implement the protocols–in layers. The service model of a layer: Each layer provides its service by (1) performing certain actions within that layer and by (2) using the services of the layer directly below it. For example, the services provided by layer n may include reliable delivery of messages from one edge of the network to the other. This might be implemented by using an unreliable edge-to-edge message delivery service of layer n-1, and adding layer n functionality to detect and retransmit lost. A protocol layer can be implemented in software, in hardware, or in a combination of the two. Layering provides a structured way to discuss system components. Modularity makes it easier to update system components. One potential drawback of layering is that one layer may duplicate lower-layer functionality. A second potential drawback is that functionality at one layer may need information that is present only in another layer. When taken together, the protocols of the various layers are called the protocol stack. Application LayerThe application layer is where network applications and their application-layer protocols reside. Protocols in the Internet’s application layer Function HTTP provide for Web document request and transfer SMTP provide for the transfer of e-mail messages FTP provide for the transfer of files between two end systems An application-layer protocol is distributed over multiple end systems, with the application in one end system using the protocol to exchange packets of information with the application in another end system. We’ll refer to the packet of information at the application layer as a message. Transport LayerThe Internet’s transports layer transports application-layer messages between application endpoints. Each of TCP and UDP can transport application-layer messages. TCP provides a connection-oriented service to its applications. This service include guaranteed delivery of application-layer messages to the destination and flow control(that is, sender/receiver speed matching). TCP breaks long messages into shorter segments and provides a congestion-control mechanism, so that a source throttles its transmission rate when the network is congested. The UDP protocol provides a connectionless service to its applications. This is a no-frills service that provides no reliability, no flow control, and no congestion control. We’ll refer to a transport-layer packet as a segment. Network LayerThe Internet’s network layer is responsible for moving network-layer packets known as datagrams from on host to another. The Internet transport-layer protocol(TCP or UDP) in a source host passes a transport-layer segment and a destination address to the network layer. The network layer then provides the service of delivering the segment to the transport layer in the destination host. The Internet’s network layer includes the IP protocol, which defines the fields in the datagram as well as how the end systems and routers act on these fields. The Internet’s network layer also contains routing protocols that determine the routes that datagram take between sources and destinations. Link LayerTo move a packet from one node(host or router) to the next node in the route, the network layer relies on the services of the link layer. Examples of link-layer protocols include Ethernet, WiFi, and the cable access network’s DOCSIS protocol. We’ll refer to the link-layer packets as frames. Physical LayerThe job of the physical layer is to move the individual bits within the frame from one node to the next. The protocols in this layer depends on the actual transmission medium of the link. For example, Ethernet has many physical-layer protocols: one for twisted-pair copper wire, another for coaxial cable, another for fiber, and so on. The OSI ModelThe Internet protocol stack is not the only protocol stack around. In the late 1970s, the International Organization for Standardization(ISO) proposed that computer networks be organized around seven layers, called the Open Systems Interconnection(OSI) model. The role of the presentation layer is to provide services that allow communicating applications to interpret the meaning of data exchanges. These services include data compression and data encryption(which are self-explanatory) as well as data description(which frees the applications from having to worry about the internal format in which data are represented/stored–formats that may differ from one computer to another). The session layer provides for delimiting and synchronization of data exchange. including the means to build a checkpointing and recovery schema. Encapsulation The figure shows the physical path that data takes down a sending end system’s protocol stack, up and down the protocol stacks of an intervening link-layer switch and router, and then up the protocol stack at the receiving end system. The figure also illustrates the importance concept of encapsulation. At the sending host, an application-layer message($ M $) is passed to the transport layer. The transport layer takes the message and appends additional information(transport-layer header information, $ H_t $) that will be used by the receiver-side transport layer. The application0layer message and the transport-layer header information together constitute the transport-layer segment. The transport-layer segment thus encapsulates the application-layer message. The added information might include information allowing the receiver-side transport layer to deliver message up to the appropriate application, and error-detection bits that allow the receiver to determine whether bits in the message have been changed in route. The transport layer then passes the segment to the network layer, which adds network-layer header information($ H_n $) such as source and destination end system address, creating a network-layer datagram. The link layer will add its own link-layer header information and create a link-layer frame. At each layer a packet has two types of fields: header fields and a payload field.]]></content>
      <categories>
        <category>Computer Networking A Top-Down Approach(7th Edition)</category>
      </categories>
      <tags>
        <tag>Computer Networks</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-08]]></title>
    <url>%2F2019%2F08%2F02%2F2019-08%2F</url>
    <content type="text"><![CDATA[这个月主要是呆在学校里面, 自己自学, 目标是Algorithms, 4th Edition by Robert Sedgewick和Computer Networking A Top-Down Approach, 7th Edition, 中间再穿插写leetcode. 重新看算法的目的一是重温一下数据结构和算法的基础知识, 以便刷leetcode题的时候不至于到处爬博客现学, 二是为了好好练练自己的Java代码的编写质量. 计网是新东西, 这本书好像同样也是用Java实现. 刷leetcode的题是为了将来在面试的时候不至于手足无措, 然后同时也是和詹蛋蛋约好的相互监督. 对于所学的东西, 我尽量以博客的形式把他们记录下来, 相当于是做了笔记. 这篇文章主要起一个索引的作用, 也将实时更新. 计算机网络 有用的笔记Chapter1 Computer Networks and the Internet 课后练习Homework Problems and Questions Chapter1 LeetCode算法与数据结构 习题&amp;例子]]></content>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我为什么这么焦虑]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E7%84%A6%E8%99%91%2F</url>
    <content type="text"><![CDATA[在期末考试之前的那段日子里得知字节跳动要和学校联合搞一个Android的暑期课程, 本着闲着也是闲着的心态填了报名表. 训练从7月11号开始, 一直持续到8月22号. 对于我而言, Android是一个全新的东西, 所以说学起来并不是那么轻松. 两个星期的速成课每天都要接收大量的信息, 每天课后还有相应的实验需要完成. 尽管有点累, 总的来说还是很充实, 最后也顺利地和家祺完成了大作业的答辩. 而现在已经是八月的第二天了, 昨天去参加了字节跳动的Android实习的面试. 结果挺惨淡, 被面试官问得心里发毛. 回来后的感觉说不上来是失落还是什么, 毕竟本来也确实是抱着不管怎样去面一下总不亏的想法, 不过确实感觉心里梗梗的, 准确来说就是焦虑吧. 为什么会有这样的焦虑呢, 可能是因为理想与现实之间的巨大落差, 更可怕的是造成这种落差的根源就是自己. 回望这两年的大学生活, 除去那么几个时间点略微地为自己考虑和规划, 更多的是被推着迷茫地向前走. 对于专业课程, 大多只是流于表面, 而没有去深究. 现在想起来, 好像大学以来就没有细致地, 完整地读过任何一本书, 大多是人云亦云, 跟风从众, 三分热度, 半途而废. 老实说, 我是一个在自我管理方面做得很差的一个人, 特别是当没有一个明确的目标时, 往往会把大量的时间浪费在无意义的社交网络上, 窥探别人的生活, 荒废自己的日子. 现在是大二结束的暑假, 好像是时候为自己未来的人生做做规划了. Android是一个有趣的东西, 在开发Android的过程中, 既能体验到前端设计的美, 又能和后端通信满足一点点控制欲. 总听到种一棵树, 最好的时机是十年前, 其次是现在. 为了在这个学期结束后的寒假找到一份满意的实习, 大概需要掌握数据结构与算法, 数据库, 操作系统, 汇编语言, 计算机网络, Android开发, Java特性等等的技能, 再多了解Android的新技术, 类似于flutter, kotlin这样的. 接下来的日子里就在这个博客里记录我的计划和学习吧.]]></content>
      <tags>
        <tag>随便聊聊</tag>
      </tags>
  </entry>
</search>
