<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小学期即时聊天软件后]]></title>
    <url>%2F2019%2F09%2F05%2F%E5%B0%8F%E5%AD%A6%E6%9C%9F%E5%8D%B3%E6%97%B6%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6%E5%90%8E%2F</url>
    <content type="text"><![CDATA[记录一下在做完小学期聊天软件项目之后, 得到的一些感触. 学习能力方面仍然欠缺太多。 在没有接触过多线程和网络编程的情况下去，我发现我学习socket编程的速度确实过慢。导致后来放弃做网络通信模块，转而做数据库模块。好在有之前数据库知识的储备，虽然也是第一次用mysql，但是无论是上手还是设计接口都来得得心应手。这算是比较满意的一个部分。 设计对于程序的重要性甚至超过编码。 就我个人编写的数据库模块而言，在我第一天初步设计好所有数据库供服务端调用的接口之后，我和吴大伟在第二天实现接口时，几乎是一气呵成，其中还包括了各个接口的简单测试。而且第一天实现好了接口，也方便服务端先调用空的接口，实现大致的代码框架。 团队合作能力的重要性。 在项目的最开始，我们便决定了使用github托管项目进行版本控制，但由于基本上大家之前要么没用过git，要么只用github托管过个人项目，不需要团队合作，也就不会有那么多的代码冲突。在我们实际的项目进行中，虽然这种情况不常见，但还是出现了版本诸如回退之后删除了本地未提交文件等错误。再就是合码真的是一个累活，既要保证自己的代码不出现问题，还要保证别人在调用的时候传入正确的参数，最后还需要自己编写的模块能使整个项目正常运转，我们合码的时间确实是过晚了，如果能重来的话，我想我会选择写一部分合一部分测一部分，而不是各个模块先分工，最后大家每个模块都完成得差不多了再进行代码的整合。 英语能力的欠缺。 对于一般的库来说，中文文档基本不能保证是最新的版本，且代码质量和代码风格也得不到保证，机翻又会导致有些专有词汇错翻。倒不是说看不懂英文文档，只是看英文文档时速度实在是太慢，只适合于看看某个函数的大致功能是啥，传入啥参数什么的。除开文档外，想要得到一些优质的问题解决方案，StackOverflow是必不可少的，基本对我来说，上StackOverflow最多看看回答者的回答，而回答下面的跟答就很少看了，总的来说还是英文能力太弱了。]]></content>
      <tags>
        <tag>随便聊聊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell命令基础]]></title>
    <url>%2F2019%2F08%2F27%2Fshell%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[小学期需要在linux环境下完成即使通讯软件, 因此需要懂一点shell的基础知识. 随手做笔记~希望里面不要出现纰漏. Base&lt;用户名&gt;@&lt;主机名&gt;:~(用户主目录, 即/home/&lt;用户名&gt;)$(#代表root用户)命令基本格式 command [option] [arguments] 查询操作:man info –help Command ls -a 显示所有 -l 详细信息 -X 按扩展名的字典序排列 -x 按行 -C 按列 -d 本目录 ls &gt; a.txt &gt; 为重定向符 即将ls得到的结果写入a.txt mvmv [1] [2]文件改名文件移到目标文件夹下文件夹移到目标文件夹下文件夹改名 cpcp [文件] [目录]cp -a [目录] [目录] (所有属性都不变)cp -r [目录] [目录] (递归拷贝, 不保留文件属性(例如文件创建时间)) mkdirmkdir -p [目录] 嵌套创建目录mkdir -m&lt;权限&gt; [目录] 权限设置例如: mkdir -m777 dir, 在当前目录下创建了一个权限为777, 文件名为dir的目录 rmrm [文件]rm -r [目录] filefile [目标文件或目录] 确定文件类型 cat/tac -n 显示行号 cat [文件1] [文件2] 合并之后展示, 不生成新的文件 cat [文件1] [文件2] &gt; [文件3] 将文件1,2合并后写入文件3 touchtouch [文件名] 创建文件 ln -s 软链接: 类似于快捷方式, 用于指向原来的文件. 删除软连接, 不影响原来的文件; 删除原文件, 软连接则不可再使用 硬链接: 默认创建硬链接, 相当于原文件的一个别名, 实际上是同一个文件. 举个栗子: 创建a.txt, 写入hello, 为a.txt创建软链接s.txt和硬链接r.txt, 删除a.txt, s.txt无法使用, r.txt仍然是hello, 重新创建a.txt, 写入world, 此时s.txt内容为world, r.txt仍为hello. 可见, 软链接靠文件名访问. tar(打包和压缩不是同一个概念) -c 创建tar文件 -f 将文件打包生成到一个文件里 如:tar -cf new.tar /home/junqi -x 对tar进行解包 tar -xf new.tar .bz2和.gz的区别: 1. .bz2比.gz压缩率更高 2. .gz比.bz2花费更少的时间 针对zip格式: 1. 打包 tar cvzf &lt;文件名&gt;.gz &lt;目录&gt; 将目录下的文件打包并压缩 2. 解包 tar xvzf &lt;文件名&gt;.gz 解压到当前目录; tar xvzf &lt;文件名&gt;.gz -C &lt;目录&gt; 解包到制定的目录下 针对biz2: 1. 打包 tar cvjf &lt;文件名&gt;.biz2 &lt;目录&gt; 将目录下的文件打包并压缩 2. 解包 tar xvjf &lt;文件名&gt;.biz2 解压到当前目录; tar xvjf &lt;文件名&gt;.biz2 -C &lt;目录&gt; 解包到制定的目录下]]></content>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#316 去除重复字母]]></title>
    <url>%2F2019%2F08%2F24%2FLeetCode-316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D%2F</url>
    <content type="text"><![CDATA[题面解:思路:总的想法是, 尽量让字典序小的字母靠前出现. 对于字符串cbacdcbc进行遍历, 在已经选择的串为c的情况下考虑第二个字母b, 因为后面仍然有c, 且b的字典序比c小, 删掉现有的c并将b加入选择的串, 这样得到的结果更优(同一个位置字典序小的字母占优, 不论后面的字母如何变幻). 第三个字母同理. 遍历到第四个和第五个字母时, 字典序呈升序, 直接加入结果仍然最优. 遍历第六个字母c时, 因为选择结果中已经出现过c, 所以不做处理(如果需要做处理, 那么就要删除已选择的元素直到至少把之前的那个c删除才能保证字典序不变大. 如果恰好删除到之前的c, 再加入现在的c, 这样的操作就毫无意义. 如果删除了更之前的, 即类似将a替换成了c, 仍然使字典序变大了). 再到b, 未出现过, 直接加入. 用StringBuilder代替栈, 方便最后转成字符串. 算法: 初始化int[] count数组, 初始化boolean[] used数组, 初始化存放结果的StringBuilder resSb和LinkedList resList 遍历一遍字符串, 记录每个字母出现的次数, count[s.charAt(i) - &#39;a&#39;]++ 遍历字符串, char letter作为当前字符, i为当前索引值. count[letter - &#39;a&#39;]-- 如果当前字符已经出现在sb中, 即used[letter - &#39;a&#39;] == true, continue. 当已选择的字串不为空resList.size() &gt; 0, 该字符的字典序小于栈顶的字符letter &lt; resList.getLast(), 且栈顶字符在字符串的后面仍然会出现count[resList.getLast() - &#39;a&#39;] &gt; 0 更新used[resList.getLast() - &#39;a&#39;] = false 弹出栈顶, resList.removeLast() 循环 添加当前字母, resList.addLast(letter), used[letter - &#39;a&#39;] = true. 遍历resList, 依次添加入resSb, 返回resSb.toString()代码:1234567891011121314151617181920212223242526272829public String removeDuplicateLetters(String s) &#123; int[] count = new int[26]; boolean[] used = new boolean[26]; StringBuilder resSb = new StringBuilder(); LinkedList&lt;Character&gt; resList = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; count[s.charAt(i) - 'a']++; &#125; char letter; for (int i = 0; i &lt; s.length(); i++) &#123; letter = s.charAt(i); count[letter - 'a']--; if (used[letter - 'a']) &#123; continue; &#125; while (resList.size() &gt; 0 &amp;&amp; letter &lt; resList.getLast() &amp;&amp; count[resList.getLast() - 'a'] &gt; 0) &#123; used[resList.getLast() - 'a'] = false; resList.removeLast(); &#125; resList.addLast(letter); used[letter - 'a'] = true; &#125; for (Character character : resList) &#123; resSb.append(character); &#125; return resSb.toString();&#125; 复杂度: 执行用时 内存消耗 语言 12ms(51.42%) 35.7MB(66.07%) Java 时间复杂度 $ O(n) $ 空间复杂度 $ O(n) $]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#232 用栈实现队列]]></title>
    <url>%2F2019%2F08%2F24%2FLeetCode-232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题面两个栈实现:思路:用一个栈作为队列尾, 另一个栈作为队列头. 形如: 算法: 入队直接压入rear 出队如果front不为空直接出front栈顶, 如果front为空, 将rear元素全部转移到front再出front栈顶. 为空判断两个栈是否都为空 队首与出队类似 代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MyQueue &#123; Stack&lt;Integer&gt; front; Stack&lt;Integer&gt; rear; /** Initialize your data structure here. */ public MyQueue() &#123; front = new Stack&lt;&gt;(); rear = new Stack&lt;&gt;(); &#125; /** Push element x to the back of queue. */ public void push(int x) &#123; rear.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ public int pop() &#123; if (empty()) &#123; throw new RuntimeException("QueueEmpty"); &#125; if (front.empty()) &#123; while (!rear.empty()) &#123; front.push(rear.pop()); &#125; &#125; return front.pop(); &#125; /** Get the front element. */ public int peek() &#123; if (empty()) &#123; throw new RuntimeException("QueueEmpty"); &#125; if (front.empty()) &#123; while (!rear.empty()) &#123; front.push(rear.pop()); &#125; &#125; return front.peek(); &#125; /** Returns whether the queue is empty. */ public boolean empty() &#123; return front.empty() &amp;&amp; rear.empty(); &#125;&#125; 复杂度: 执行用时 内存消耗 语言 83ms(90.67%) 35MB(43.88%) Java 时间复杂度: 分摊下来为$ O(1) $, 对于任意$n$个元素的入队和出队来说, 其操作总次数都不会超过$4n$次, 即每个元素都入队列且都出队(相当于每个元素都入rear栈, 出rear栈, 进front栈, 再出front栈). 但对于某一次的出队操作来说, 其时间复杂度会出现$ O(n) $的情况. 空间复杂度 $ O(n) $, 需要两个栈存元素.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#85 最大矩形]]></title>
    <url>%2F2019%2F08%2F20%2FLeetCode-85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[题面运用栈:思路:为方便讨论, 假定矩阵的层数从上往下依次递增. 假定最大矩形的底边在第n层, 对于第n层中为”0”的那些列, 对最大矩形无贡献. 对于第n层中为”1”的那些列, 最大矩形的高度为某一个”1”往上的连续个”1”之和. 遍历矩阵的层, 对每层按LeetCode#84 柱状图中最大的矩形的算法求出对应的面积. 要求的最大面积为这n层所求面积中最大的那个. 算法: 初始化高度数组heights[matrix.length][matrix[0].length], maxArea = 0 按层遍历matrix, 对于矩阵的每层, 更新相应的heights[i][] 按照LeetCode#84 柱状图中最大的矩形中的算法传入高度数组, 更新maxArea 代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445public int maximalRectangle(char[][] matrix) &#123; if (matrix == null || matrix.length == 0) &#123; return 0; &#125; int maxArea = 0; int[][] heights = new int[matrix.length][matrix[0].length]; for (int i = 0; i &lt; heights.length; i++) &#123; for (int j = 0; j &lt; heights[0].length; j++) &#123; if (i == 0) &#123; heights[i][j] = matrix[i][j] == '0' ? 0 : 1; &#125; else &#123; heights[i][j] = matrix[i][j] == '0' ? 0 : heights[i - 1][j] + 1; &#125; &#125; &#125; for (int[] height : heights) &#123; maxArea = Math.max(maxArea, maxHistogramRectangle(height)); &#125; return maxArea; &#125;static private int maxHistogramRectangle(int[] heights) &#123; int maxArea = 0; Stack&lt;Integer&gt; heightsIndexStack = new Stack&lt;&gt;(); heightsIndexStack.push(-1); for (int i = 0; i &lt; heights.length; i++) &#123; while (heightsIndexStack.peek() != -1 &amp;&amp; heights[i] &lt;= heights[heightsIndexStack.peek()]) &#123; int mid = heightsIndexStack.pop(); int width = i - heightsIndexStack.peek() - 1; maxArea = Math.max(maxArea, heights[mid] * width); &#125; heightsIndexStack.push(i); &#125; while (heightsIndexStack.peek() != -1) &#123; int mid = heightsIndexStack.pop(); int width = heights.length - heightsIndexStack.peek() - 1; maxArea = Math.max(maxArea, heights[mid] * width); &#125; return maxArea;&#125; 复杂度: 执行用时 内存消耗 语言 54ms(27.98%) 49.3MB(45.00%) Java 假定矩阵为$ m \times n $矩阵 时间复杂度 $ O(m*n) $, 计算heights[][]需要$ O(m * n) $; 遍历层数, 对每层求最大面积需要$ O(m * n) $. 空间复杂度 $ O(m*n) $, 存放高度的heights[][]需要$ O(m * n) $; 栈需要$ O(n) $.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#84 柱状图中最大的矩形]]></title>
    <url>%2F2019%2F08%2F19%2FLeetCode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[题面 暴力解:思路:对于每个出现的柱子高度, 找到该高度对应的最大面积.对于高度2, 1, 5, 6, 2, 3, 出现了1, 2, 3, 5, 6五个高度. 我们只需遍历一遍这五个高度, 找出每个高度对应的连续的高大于等于该高度的柱子数即可. 算法: 创建HashSet, 对高度进行去重. 以height遍历HashSet中每一个高度 初始化maxWidth = 0, width = 0 遍历原柱子数组 如果当前高度大于height, width++. 否则, maxWidth = Math.max(maxWidth, width), width = 0. 再次更新maxWidth, 以比较最后一串连续的柱子宽和maxWidth. 更新最大面积maxArea 代码:12345678910111213141516171819202122232425static public int largestRectangleArea(int[] heights) &#123; int maxArea = 0; HashSet&lt;Integer&gt; heightSet = new HashSet&lt;&gt;(); for (int height : heights) &#123; heightSet.add(height); &#125; for (Integer height : heightSet) &#123; int maxWidth = 0; int width = 0; for (int currentHeight : heights) &#123; if (currentHeight &gt;= height) &#123; width++; &#125; else &#123; maxWidth = Math.max(maxWidth, width); width = 0; &#125; &#125; maxWidth = Math.max(maxWidth, width); maxArea = Math.max(maxArea, maxWidth * height); &#125; return maxArea;&#125; 复杂度: 执行用时 内存消耗 语言 708ms(18.85%) 44.3MB(20.35%) Java 时间复杂度 $ O(n^2) $, 最坏情况, 当所有柱子高度都不同, 且依次递增时, 内外循环次数都为n 空间复杂度 $ O(n) $, HashSet占用额外$ O(n) $ 空间复杂度为$ O(n^2) $时, 会爆内存. 应用单调栈思路:遍历每个柱子, 对每个柱子而言, 他所能达到的最大面积为, 最小高度为该柱子的高度, 宽度最宽的矩形. 即对于每个柱子, 要找到他左右两边第一个小于他的柱子, 中间形成的矩形的面积便是该柱子所能达到的最大面积. 这样的思路和LeetCode#42 接雨水就很像了, 考虑运用单调栈解决问题. 考虑一排递增的柱子, 每个柱子的左边第一个便是第一个小于他的柱子. 我们用栈来维护这样一个递增的序列. 遍历所有柱子, 如果当前柱子的高度大于等于栈顶柱子的高度, 则直接压栈; 否则, 当前柱子便是现在的栈顶柱子的右边第一个小于他的柱子, 将当前柱子记作right, 弹出栈顶元素记作mid, 弹出后的新栈顶便是mid左边第一个小于他的柱子, 记作left, 这样便可以求出以heights[mid]为高度, 介于left和right之间的矩形面积最大值. 算法: 初始化栈heightIndexStack, 压入-1(索引-1可作为任意右边柱子的左边界); 初始化最大面积maxArea = 0 遍历所有柱子, 当前遍历到的柱子索引记作current 如果栈不为空(即栈顶元素不为-1)且当前柱子的高度小于等于栈顶柱子的高度(如果去掉等于, 假定一组高度为1, 1, 2, 2, 1, 那么当读到最后一个1时, 栈内为-1, 0, 1, 2, 3, 显然当索引3作为中间值的时候, 索引2并不能成为其左边界). 弹出栈顶元素, 记作mid 以heights[mid]为高度的最大矩形区域的宽为width = current - heightIndexStack.peek() - 1 更新maxArea = Math.max(maxArea, heights[mid] * width) 将当前柱子索引压栈 若此时栈仍然不为空(即栈顶元素不为-1), 相当于current移动到heights.length的位置, 继续更新maxArea直到栈空代码:1234567891011121314151617181920212223242526static public int largestRectangleArea(int[] heights) &#123; if (heights == null || heights.length == 0) &#123; return 0; &#125; int maxArea = 0; Stack&lt;Integer&gt; heightIndexStack = new Stack&lt;&gt;(); heightIndexStack.push(-1); for (int current = 0; current &lt; heights.length; current++) &#123; while (heightIndexStack.peek() != -1 &amp;&amp; heights[current] &lt;= heights[heightIndexStack.peek()]) &#123; int mid = heightIndexStack.pop(); int width = current - heightIndexStack.peek() - 1; maxArea = Math.max(maxArea, width * heights[mid]); &#125; heightIndexStack.push(current); &#125; while (heightIndexStack.peek() != -1) &#123; int mid = heightIndexStack.pop(); int width = heights.length - heightIndexStack.peek() - 1; maxArea = Math.max(maxArea, width * heights[mid]); &#125; return maxArea;&#125; 复杂度: 执行用时 内存消耗 语言 44ms(42.76%) 43.1MB(34.64%) Java 时间复杂度 $ O(n) $, 每个元素入栈出栈两次操作. 空间复杂度 $ O(n) $, 栈需要额外的$ O(n) $空间.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Stack</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#42 接雨水]]></title>
    <url>%2F2019%2F08%2F17%2FLeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[题面 暴力解:思路:对于每个元素, 其能达到的最大高度为该元素左边所有元素中的最大值和右边所有元素中的最大值其中较小的那一个. 算法: 初始化res为0 便利整个height数组 初始化 leftMax = height[left], rightMax = height[right] 从当前元素向左扫描并更新leftMax 从当前元素向右扫描并更新rightMax 当左右最大元素值均比当前元素值大时, res += Math.min(leftMax, rightMax) - height[i]; 代码:1234567891011121314151617181920212223242526static public int trap(int[] height) &#123; int res = 0; for (int i = 1; i &lt; height.length - 1; i++) &#123; int left = i - 1, right = i + 1; int leftMax = height[left]; int rightMax = height[right]; while (left &gt;= 0) &#123; if (leftMax &lt; height[left]) &#123; leftMax = height[left]; &#125; left--; &#125; while (right &lt;= height.length - 1) &#123; if (rightMax &lt; height[right]) &#123; rightMax = height[right]; &#125; right++; &#125; if (height[i] &lt; leftMax &amp;&amp; height[i] &lt; rightMax) &#123; res += Math.min(leftMax, rightMax) - height[i]; &#125; &#125; return res;&#125; 复杂度: 执行用时 内存消耗 语言 152ms(5.4%) 42MB(60.13%) Java 时间复杂度 $ O(n) $, 对于每个元素, 都要从扫描整个数组 空间复杂度 $ O(1) $ 应用栈:思路:遍历数组时, 用栈来追踪可能储水的长条或作为”墙”的长条. 储水长条和”墙”长条的概念是相对的, 可以变动. 有水坑的必要条件是当前扫描到的长条作为”墙”长条, 栈中至少有一个储水长条和一个”墙”长条, 这样即可填平”一层”(“一层”的高可能超过1, 这里指的是一层或多层宽度相同的方块条叠起来). 层层填平后, 当前位置之前的所有水坑已填平(当作后面已经没有长条). 当前长条将作为新的储水长条或”墙”长条压入栈. 当前长条的高度小于栈顶高度时, 将当前长条压入栈.当前长条的高度大于或等于栈顶长条的高度时, 层层填平两个长条中间的部分, 并将当前长条压入栈. 算法: 使用栈stack来保存长条的索引 遍历数组 当栈不为空且当前元素的高度大于或等于栈顶元素的高度 弹出栈顶元素topIndex. 若栈为空(意味着之前的坑全部填平, 且无论怎么填后面的坑都不会对之前的坑有影响), 跳出循环. 计算要填的”一层”坑的宽度: trapWidth = current - stack.peek() - 1, 高度: trapHeight = Math.min(height[current], height[stack.peek()]) - height(topIndex). 填坑, res += trapWidth * trapHeight. 重复以上操作. 将当前元素压入栈 图示: 代码:123456789101112131415161718static public int trap(int[] height) &#123; int res = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int current = 0; current &lt; height.length; current++) &#123; while (!stack.empty() &amp;&amp; height[current] &gt;= height[stack.peek()]) &#123; int topIndex = stack.pop(); if (stack.empty()) &#123; break; &#125; int trapWidth = current - stack.peek() - 1; int trapHeight = Math.min(height[current], height[stack.peek()]) - height[topIndex]; res += trapWidth * trapHeight; &#125; stack.push(current); &#125; return res;&#125; 复杂度: 执行用时 内存消耗 语言 15ms(19.33%) 37.1MB(85.67%) Java 时间复杂度 $ O(n) $, 每个条形快最多访问两次, 即压入和弹出操作$ O(1) $. 空间复杂度 $ O(n) $, 栈最多占用$ O(n) $的空间]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Homework Problems and Questions Chapter1]]></title>
    <url>%2F2019%2F08%2F11%2FHomework-Problems-and-Questions-Chapter1%2F</url>
    <content type="text"><![CDATA[Review QuestionsSECTION 1.1 没有区别; 手机, PC, iPad, 服务器, 智能家居终端; 算. A protocol is a rule which describes how an activity should be performed, especially in the field of diplomacy. In diplomatic services and governmental fields of endeavor protocols are often unwritten guidelines. Protocols specify the proper and generally accepted behavior in matters of state and diplomacy. 开发者可以根据协议标准开发可以互相通信的网络系统, 标准不同则无法通信. SECTION 1.2 Class Access Technologies Home Access DSL Internet Access, Cable Internet Access, FTTH, Satellite access, Dial-up access, WiFi Enterprise Access 100 Mbps Ethernet, WiFi. Wide-area Wireless Access 3G, 4G, 5G HFC 带宽是用户间共享的. 下行通道是共享的, 每个分组由单一的头端发送向下行径每段链路到每个家庭, 藉由分布式多路访问协议可避免碰撞. Access Technologies Upstream Rate Downstream Rate Monthly Price FTTH 20 Mbps 200 Mbps 60元 4G 7.72 Mbps 38.2 Mbps 17元 使用以太网接入, 用户通常以100Mbps速率接入以太网交换机, 而服务器可能具有1Gbps甚至10Gbps的接入速率. 绝大部分是双绞铜线, 也能运行在光纤上. Access Technologies Transmission Rates Bandwidth DSL 55 Mbps downstream and 15 Mbps upstream dedicated HFC up to 42.8 Mbps downstream and 30.7 Mbps upstream shared FTTH 2-10 Mbps upload; 10-20 Mbps download shared Dial up 56 kbps dedicated WiFi 和 4G 技术:a) 在无线LAN环境中, 无线用户必须位于接入点几十米范围内发送或接收分组. 传输速率高达54Mbps. 接入点一般连接着有线因特网, 将无线用户接入有线网络.b) 分组通过蜂窝网提供商运营的基站来发送和接受, 一个用户只需位于基站的数万米内. SECTION 1.3 0时刻发送主机开始发送, $ t_1 = L / R_1 $ 时刻发送主机完成发送, 由于没有传播时延, 同时刻整个分组被路由器接收, 并同时由路由器开始发送向接收主机. $ t_2 = t_1 + L / R_2 $时刻, 路由器发送完分组, 整个分组被接收主机接收. 所以端对端时延为$ L / R_1 + L / R_2 $. 电路交换网络在端系统通信会话期间, 预留了端系统间通信沿路径所需的资源(缓存, 链路传输速率). 绝大部分的分组交换网络不能保证端对端通信的带宽. 频分复用需要复杂的模拟硬件来讲信号转换到合适的频带. a. $ 2 / 1 = 1 $b. 在发送时, 每个用户需要1 Mbps, 如果两个或更少的用户同时传输, 最多需要2 Mbps. 共享链路的带宽是2 Mbps, 所以不会有排队时延. 当有3个及以上的用户同时发送时, 他们需要3 Mbps或更多, 带宽无法满足, 于是存在排队时延.c. $ 0.2 $d. 三个用户同时发送数据的概率为 $ 0.2^3 $, 只有当三个用户同时发送数据时, 队列才会增长, 故队列增长的时间比例也是 $ 0.2^3 $. 如果同等级的ISP不对等的话, 相互通信则需要向提供商ISP支付流量成本. IXP可以向连接着他的ISP收取费用. 谷歌的专用网络连接起了它所有的数据中心. 谷歌的数据中心之间的流量通过其专用网络传输, 而不是公共因特网. 谷歌的数据中心直接与低级别的ISP连接, 所以当谷歌向用户提供内容时, 可以绕过更高级别的ISP; 首先, 因为它使用很少的中间ISP, 所以内容提供商可以提供更好的用户体验. 其次, 它可以向提供商网络发送更少的流量节省费用. SECTION 1.4 处理时延, 排队时延, 传输时延, 传播时延. 除了排队时延, 其他的都是确定的. Transmission vs Propagation Delaya. $1000km, 10^8m/s, 1Mbps, 100Bytes$b. $10km, 2.9\times10^8m/s, 1Mbps, 100Bytes$ $t = \frac{2500km}{2.5\cdot10^8m/s} = 10ms$, $ d/s $, no, no. a. 500 kbpsb. 64sc. 320s 如何生成分组: 将文件分块 在每个块前加上header形成分组 每个分组包含目的地的IP地址 分组交换器如何将分组转发到对应的链路: 分组交换其识别分组中的IP地址来确定转发的链路. 比喻: 车比作分组, 拿着目的地地址问路比作分组交换器识别分组中的IP地址并转发分组到相应的链路. Queuing and Loss最大的发送速率: 200 packets/minute最小的传输速率: 1 packets/minute流量强度为200当发送的过程相同时, 两次的初始丢包时间相同. SECTION 1.5 error control, flow control, segmentation and reassembly, multiplexing, and connection setup; yes. the application layer, the transport layer, the network layer, the link layer, the physical layer.Principal responsibilities:Application layer: HTTP, SMTP, and FTP protocols are used in application layer. it is used to send data over multiple end systems. Transport layer: Transfer the content between two endpoints mainly. TCP and UDP protocols are used in transport layer. Network layer: Move the packets between any two hosts in the network. IP protocol is used in network layer. Data link layer: Move the packets from one node to the next another node. Point-to-point protocol (ppp) used in data link layer. Physical layer: Transfer the individual bits from one node to the next node with in the frame. 应用层报文: 应用程序想要发送并传递到传输层的数据运输层报文段: 封装了应用层应用层报文和传输层标头网络层数据报: 封装了运输层报文段和网络层标头链路层帧: 封装了网络层数据报和链路层标头 网络层, 链路层, 物理层; 链路层, 物理层; 五层都处理 SECTION 1.6 病毒需要与人交互才能传播. 蠕虫可以自己扫描IP地址和端口号, 寻找可以注入的进程 创造僵尸网络: 攻击者寻找有漏洞的主机系统 用木马破坏主机系统用于DDoS: 僵尸网络中的任何系统都可以利用漏洞自动扫描环境并传播 创造僵尸网络的人可以远程控制僵尸网络中的所有节点 攻击者可以命令僵尸网络中的所有节点向某个节点攻击 Problems]]></content>
      <categories>
        <category>Computer Networking A Top-Down Approach(7th Edition) RQ&amp;P</category>
      </categories>
      <tags>
        <tag>Computer Networks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter1 Computer Networks and the Internet]]></title>
    <url>%2F2019%2F08%2F04%2FChapter1-Computer-Networks-and-the-Internet%2F</url>
    <content type="text"><![CDATA[What Is the InternetA Nuts-and-Bolts DescriptionThe Internet is a computer network that interconnects billions of computing devices throughout the world. All of these devices are called hosts or end systems. End systems are connected together by a network of communication links and packet switches. Transmission rate is measured in bits/second. When one end system has data to send to another end system, the sending end system segments the data and adds header bytes to each segment. The resulting packages of information is known as packets. The two most prominent types in today’s Internet are routers and link-layer switches. The sequence of communication links and packet switches traversed by a packet from the sending end system to the receiving end system is known as a route or path through the network. End systems access the Internet through Internet Service Providers (ISPs). Protocols control the sending and receiving of information within the Internet. The Transmission Control Protocol(TCP) and the Internet Control Protocol(TCP) are two of the most important protocols in the Internet. Internet standards are developed by the Internet Engineering Task Force(IETF). The IETF standards documents are called request for comments(RFCs). A Services DescriptionThe applications that Internet provides services to are said to be distributed applications, since they involve multiple end systems that exchange data with each other. Socket interface specifies how a program running on one end system asks the Internet infrastructure to deliver data to a specific destination program running on another end system. What Is a Protocol?A protocol defines the format and the order of messages exchanged between two or more communicating entities, as well as the actions taken on the transmission and/or receipt of a message or other event. The Network EdgeHosts are sometimes further divided into two categories: clients and servers. Access Networks The access network is the network that physically connects and end system to the first router(also known as the “edge router”). Home AccessToday, the two most prevalent types of broadband residential access are digital subscriber line(DSL) and cable. For the DSL Internet access, the residential telephone line carries both data and traditional telephone signals simultaneously, which are encoded at different frequencies: A high-speed downstream channel, in the 50 kHz to 1 MHz band A medium-speed upstream channel, in the 4 kHz to 50 kHz band An ordinary two-way telephone channel, in the 0 to 4 kHz band The DSL standards define multiple transmission rates, including 55 Mbps downstream and 15 Mbps upstream[ITU 2006]. The access is said to be asymmetric. One important characteristic of cable Internet access is that it is a shared broadcast medium. In particular, every packet sent by the head end travels downstream on every link to every home and every packet sent by a home travels on the upstream channel to the head end. While DSL makes use of telco’s existing local telephone infrastructure, cable Internet access makes use of the cable television company’s existing cable television infrastructure. The cable Internet access is typically asymmetric, with downstream channel typically allocated a higher transmission rate than the upstream channel. The DOCSIS 2.0 standard defines downstream rates up to 42.8 Mbps and upstream rates of up to 30.7 Mbps. An up-and-coming technology that provides even higher speeds is fiber to the home(FTTH). The FTTP concept is simple–provide an optical fiber path from the CO directly to the home. This image shows FTTH using the passive optical network(PON) distribution architecture. Each home has an optical network terminator(ONT), which is connected by dedicated optical fiber to a neighborhood splitter. The splitter combines a number of homes onto a single, shared optical fiber, which connects to an optical line terminator(OLT) in the telco’s CO. The OLT, providing conversion between optical and electrical signals, connects to the Internet via a teleco router. In locations where DSL, cable, and FTTH are not available, a satellite link can be used to connect a residence to the Internet at speeds of more than 1 Mbps. Dial-up access over traditional phone lines is based on the same model as DSL–a home modem connects over a phone line to a modem in the ISP. Dial-up access is excruciatingly slow at 56 kbps. Access in the Enterprise (and the Home): Ethernet and WiFi On corporate and university campuses, and increasingly in home settings, a local area network(LAN) is used to connect an end system to the edge router. Ethernet is by far the most prevalent access technology in many types of LAN technologies. With Ethernet access, users typically have 100 Mbps or 1 Gbps access to the Ethernet switch, whereas servers may have 1 Gbps or even 10 Gbps access. Wireless LAN access based on IEEE 802.11 technology, more colloquially known as WiFi, is now everywhere. 802.11 today provides a shared transmission rate of up to more than 100 Mbps. Wide-Area Wireless Access: 3G and LTEDevices like smartphones employ the same wireless infrastructure used for cellular telephony to send/receive packets through a base station that is operated by the cellular network provider. Physical MediaFor each transmitter-receiver pair, a bit is sent by propagating electromagnetic waves or optical pulses across a physical medium. Physical medium fall into two categories: guided media and unguided media. With guided media, the waves are guided along a solid medium, such as a fiber-optic cable, a twisted-pair copper wire, or a coaxial cable. With unguided media, the waves propagate in the atmosphere and in outer space, such as in a wireless LAN or a digital satellite channel. Twisted-Pair Copper WireThe least expensive and most commonly used guided transmission medium. Unshielded twisted pair(UTP) is commonly used for computer networks within a building, that is, for LANs. Data rates for LANs using twisted pair today range from 10 Mbps to 10 Gbps, which depend on the thickness of the wire and the distance between transmitter and receiver. Coaxial CableLike twisted pair coaxial cable consists of two copper conductors, but the two conductors are concentric rather than parallel, which can make coaxial cable achieve high data transmission rates. Coaxial cable can be used as a guided shared medium. Fiber OpticsAn optical fiber is a thin, flexible medium that conducts pulses of light, with each pulse representing a bit. A single optical fiber can support tremendous bit rates, up to tens of even hundreds of gigabits per second. They are immune to electromagnetic interference. Terrestrial Radio ChannelsThey require no physical wire to be installed. Satellite Radio ChannelsThe communication satellite receives transmissions on one frequency band, regenerates the signal using a repeater, and transmits the signal on another frequency. The Network Core Packet SwitchingIn a network application, end systems exchange messages with each other.To send message from a source end system to a destination end system, the source breaks long messages into smaller chunks of data known as packets. Between source and destination, each packet travels through communication links and packet switches(two predominant types, routers and link-layer switches). Store-and-Forward TransmissionMost packet switches use store-and-forward transmission at the inputs to the links. It means that the packet switch must receive the entire packet before it can begin to transmit the first bit of the packet onto the outbound link. Queuing Delays and Packet LossEach packet switch has multiple links attached to it. For each attached link, the packet switch has an output buffer(also called an output queue), which stores packets that the router is about to send into the link. Due to this, packets suffer output buffer queuing delays. When an arriving packet find that the buffer is completely full with other packets waiting for transmission, packet loss will occur–either the arriving packet or one of the already-queued packets will be dropped. Forwarding Tables and Routing ProtocolsIn the Internet, every end system has an address called an IP address. A packet source includes the destination’s IP address in the packet’s header. Each router has a forwarding table that maps destination addresses(or portions of the destination addresses) to that router’s outbound links. The Internet has a number of special routing protocols that are used to automatically set the forwarding tables. A routing protocol may, for example, determine the shortest path from each router to each destination and use the shortest path results to configure the forwarding tables in the routers. Circuit SwitchingThere are two fundamental approaches to moving data through a network of links and switches: circuit switching and packet switching. In circuit-switched networks, the resources(buffers, link transmission rate) needed along a path to provide for communication between the end systems are reserved for the duration of the communication session between the end systems. In packet-switched networks, these resources are not reserved. Consider the traditional telephone networks, the network must establish a connection between the sender and the receiver. The switches on the path between the sender and receiver maintain connection state for that connection. This connection is called a circuit. Multiplexing in Circuit-Switched NetworksA circuit in a link is implemented with either frequency-division multiplexing(FDM) or time-division multiplexing(TDM). With FDM, the frequency spectrum of a link is divided up among the connections established across the link. The link dedicates a frequency band to each connection for the duration of the connection. The width of the band is called bandwidth. For a TDM link, time is divided into frames of fixed duration, and each frame is divided into a fixed number of time slots. These slots are dedicated for the sole use of that connection. Packet Switching Versus Circuit SwitchingPacket switching has end-to-end delays is variable and unpredictable.(due primarily to variable and unpredictable queuing delays) But it offers better sharing of transmission capacity than circuit switching and it is simpler, more efficient, and less costly to implement than circuit switching. Circuit switching pre-allocates use of the transmission link regardless of demand, with allocated but unneeded link time going unused. Packet switching on the other hand allocates link use on demand. A Network of NetworksBy creating a network of networks, the puzzle, the access ISPs themselves must be interconnected is completed. A points of presence(PoP) is simply group of one or more routers(at the same location) in the provider’s network where customer ISPs can connect into the provider IPS. PoPs exist in all levels of the hierarchy, except for the bottom(access ISP) level. For a customer network to connect to a provider’s PoP, it can lease a high-speed link from a third-party telecommunications provider to directly connect one of its routers to a router at the PoP. Any ISP(except for tier-1 ISPs) may choose to multi-home, that is, to connect to two or more provider ISPs. To reduce the costs that a customer ISP pays a provider ISP for amount of traffic, a pair of nearby ISPs at the same level of the hierarchy can peer. They can directly connect their networks together so that all the traffic between them passes over the direct connection rather than through upstream intermediaries. Along these same lines, a third-party company can create an Internet Exchange Point(IXP), which is a meeting point where multiple ISPs can peer together. Content provider, like Google, can created its own networks and connect directly into lower-tier ISPs(settlement free) where possible. Delay, Loss, and Throughput in Packet-Switched Networks.Computer networks necessarily constrain throughput(the amount of data per second that can be transferred) between end systems, introduce delays between end systems, and can actually lose packets. Overview of Delay in Packet-Switched NetworksThe most important delays are the nodal processing delay, queuing delay, transmission delay, and propagation delay; together, these delays accumulate to give a total nodal delay. Processing DelayThe time required to examine the packet’s header and determine where to direct the packet is part of the processing delay. Processing delays in the high-speed routers are typically on the order of microseconds or less. Queuing DelayAt the queue, the packet experiences a queuing delay as it waits to be transmitted onto the link. Queuing delays can be on the order of microseconds to milliseconds in practice. Transmission DelayDenote the length of the packet by $ L $ bits, and denote the transmission rate of the link from router A to router B by $ R $ bits/sec. The transmission delay is $ L/R $. This is the amount of time required to push(that is, transmit) all of the packet’s bits into the link. Transmission delays are typically on the order of microseconds to milliseconds in practice. Propagation DelayOnce a bit is pushed into the link, it needs to propagate to router B. The time required to propagate from the beginning of the link to router B is the propagation delay. The propagation speed depends on the physical medium of the link(that is, fiber optics, twisted-pair copper wire, and so on) and is in the range of $ 2 \times 10^8 $ meters/sec to $ 3 \times 10^8 $ meters/sec. The propagation delay is the distance between two routers divided by the propagation speed. In wide-area networks, propagation delays are on the order of milliseconds. Comparing Transmission and Propagation DelayThe transmission delay is the amount of time required for the router to push out the packet; it has nothing to do with the distance between the two routers. The propagation delay is the time it takes a bit to propagate from one router to the next; it is a function of the distance between the two routers, but has nothing to do with the packet’s length or the transmission rate of the link. Queuing Delay and Packet LossThe most complicated and interesting component of nodal delay is the queuing delay. The rate at which traffic arrives at the queue, the transmission rate of the link, and the nature of the arriving traffic, that is whether the traffic arrives periodically or arrives in bursts, impacts the queuing delay. Let $ a $ packets/sec denote the average rate at which packets arrive at the queue. $ R $ bits/sec is the transmission rate. All packets consist of $ L $ bits. Then the average rate at which bits arrive at the queue is $ La $ bits/sec. The ratio $ La/R $, called traffic intensity, often plays an important role in estimating the extent of the queuing delay. One of the golden rules in traffic engineering is: Design your system so that the traffic intensity is no greater than 1. Consider the case $ La/R \leq 1 $. Here, the nature of the arriving traffic impacts the queuing delay. Typically, the arrival process to a queue is random. Packet LossIn reality a queue preceding a link has finite capacity. Packet delays do not really approach infinity as the traffic intensity approaches 1. Instead, a packet can arrive to find a full queue. With no place to store such a packet, a router will drop the packet; that is, the packet will be lost. Therefore, performance at a node is often measured not only in terms of delay, but also in terms of the probability of packet loss. End-to-End delaySuppose there are $ N-1 $ routers between the source host and the destination host. $ d_{proc} $ is the processing delay at each router and at the source host. The transmission rate out of each router and out of the source host is $ R $ bits/sec, and the propagation on each link is $ d_{prop} $. The nodal delays accumulate and give an end-to-end delay, $$ d_{end-end} = N(d_{proc} + d_{trans} + d_{prop}) $$, where, $ d_{trans} = L/R $, where $ L $ is the packet size. Throughput in Computer NetworksIn addition to delay and packet loss, another critical performance measure in computer networks is end-to-end throughput. The instantaneous throughput at any instant of time is the rate (in bits/sec) at which Host B is receiving the file from Host A. For some applications, including those involving file transfers, delay is not critical, but it is desirable to have the highest possible throughput. The constraining factor for throughput in today’s Internet is typically the access network because the core of the Internet is over-provisioned with high speed links that experience little congestion. When there is no other intervening traffic, the throughput for a file transfer is the transmission rate of the bottleneck link along the path between server and client. More generally, the throughput depends not only on the transmission rates of the links along the path, but also on the intervening traffic. Protocol Layers and Their Service ModelsFor organizing a network architecture, or at least our discussion of network architecture. Layered ArchitectureEach layer provides its service by (1) performing certain actions within that layer and by (2) using the services of the layer directly below it. For large and complex systems that constantly being updated, the ability to change the implementation of a service without affecting other components of the system is another important advantage of layering. Protocol LayeringTo provide structure to the design of network protocols, network designers organize protocols–and the network hardware and software that implement the protocols–in layers. The service model of a layer: Each layer provides its service by (1) performing certain actions within that layer and by (2) using the services of the layer directly below it. For example, the services provided by layer n may include reliable delivery of messages from one edge of the network to the other. This might be implemented by using an unreliable edge-to-edge message delivery service of layer n-1, and adding layer n functionality to detect and retransmit lost. A protocol layer can be implemented in software, in hardware, or in a combination of the two. Layering provides a structured way to discuss system components. Modularity makes it easier to update system components. One potential drawback of layering is that one layer may duplicate lower-layer functionality. A second potential drawback is that functionality at one layer may need information that is present only in another layer. When taken together, the protocols of the various layers are called the protocol stack. Application LayerThe application layer is where network applications and their application-layer protocols reside. Protocols in the Internet’s application layer Function HTTP provide for Web document request and transfer SMTP provide for the transfer of e-mail messages FTP provide for the transfer of files between two end systems An application-layer protocol is distributed over multiple end systems, with the application in one end system using the protocol to exchange packets of information with the application in another end system. We’ll refer to the packet of information at the application layer as a message. Transport LayerThe Internet’s transports layer transports application-layer messages between application endpoints. Each of TCP and UDP can transport application-layer messages. TCP provides a connection-oriented service to its applications. This service include guaranteed delivery of application-layer messages to the destination and flow control(that is, sender/receiver speed matching). TCP breaks long messages into shorter segments and provides a congestion-control mechanism, so that a source throttles its transmission rate when the network is congested. The UDP protocol provides a connectionless service to its applications. This is a no-frills service that provides no reliability, no flow control, and no congestion control. We’ll refer to a transport-layer packet as a segment. Network LayerThe Internet’s network layer is responsible for moving network-layer packets known as datagrams from on host to another. The Internet transport-layer protocol(TCP or UDP) in a source host passes a transport-layer segment and a destination address to the network layer. The network layer then provides the service of delivering the segment to the transport layer in the destination host. The Internet’s network layer includes the IP protocol, which defines the fields in the datagram as well as how the end systems and routers act on these fields. The Internet’s network layer also contains routing protocols that determine the routes that datagram take between sources and destinations. Link LayerTo move a packet from one node(host or router) to the next node in the route, the network layer relies on the services of the link layer. Examples of link-layer protocols include Ethernet, WiFi, and the cable access network’s DOCSIS protocol. We’ll refer to the link-layer packets as frames. Physical LayerThe job of the physical layer is to move the individual bits within the frame from one node to the next. The protocols in this layer depends on the actual transmission medium of the link. For example, Ethernet has many physical-layer protocols: one for twisted-pair copper wire, another for coaxial cable, another for fiber, and so on. The OSI ModelThe Internet protocol stack is not the only protocol stack around. In the late 1970s, the International Organization for Standardization(ISO) proposed that computer networks be organized around seven layers, called the Open Systems Interconnection(OSI) model. The role of the presentation layer is to provide services that allow communicating applications to interpret the meaning of data exchanges. These services include data compression and data encryption(which are self-explanatory) as well as data description(which frees the applications from having to worry about the internal format in which data are represented/stored–formats that may differ from one computer to another). The session layer provides for delimiting and synchronization of data exchange. including the means to build a checkpointing and recovery schema. Encapsulation The figure shows the physical path that data takes down a sending end system’s protocol stack, up and down the protocol stacks of an intervening link-layer switch and router, and then up the protocol stack at the receiving end system. The figure also illustrates the importance concept of encapsulation. At the sending host, an application-layer message($ M $) is passed to the transport layer. The transport layer takes the message and appends additional information(transport-layer header information, $ H_t $) that will be used by the receiver-side transport layer. The application0layer message and the transport-layer header information together constitute the transport-layer segment. The transport-layer segment thus encapsulates the application-layer message. The added information might include information allowing the receiver-side transport layer to deliver message up to the appropriate application, and error-detection bits that allow the receiver to determine whether bits in the message have been changed in route. The transport layer then passes the segment to the network layer, which adds network-layer header information($ H_n $) such as source and destination end system address, creating a network-layer datagram. The link layer will add its own link-layer header information and create a link-layer frame. At each layer a packet has two types of fields: header fields and a payload field.]]></content>
      <categories>
        <category>Computer Networking A Top-Down Approach(7th Edition)</category>
      </categories>
      <tags>
        <tag>Computer Networks</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-08]]></title>
    <url>%2F2019%2F08%2F02%2F2019-08%2F</url>
    <content type="text"><![CDATA[这个月主要是呆在学校里面, 自己自学, 目标是Algorithms, 4th Edition by Robert Sedgewick和Computer Networking A Top-Down Approach, 7th Edition, 中间再穿插写leetcode. 重新看算法的目的一是重温一下数据结构和算法的基础知识, 以便刷leetcode题的时候不至于到处爬博客现学, 二是为了好好练练自己的Java代码的编写质量. 计网是新东西, 这本书好像同样也是用Java实现. 刷leetcode的题是为了将来在面试的时候不至于手足无措, 然后同时也是和詹蛋蛋约好的相互监督. 对于所学的东西, 我尽量以博客的形式把他们记录下来, 相当于是做了笔记. 这篇文章主要起一个索引的作用, 也将实时更新. 计算机网络 有用的笔记Chapter1 Computer Networks and the Internet 课后练习Homework Problems and Questions Chapter1 LeetCode算法与数据结构 习题&amp;例子]]></content>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我为什么这么焦虑]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E7%84%A6%E8%99%91%2F</url>
    <content type="text"><![CDATA[在期末考试之前的那段日子里得知字节跳动要和学校联合搞一个Android的暑期课程, 本着闲着也是闲着的心态填了报名表. 训练从7月11号开始, 一直持续到8月22号. 对于我而言, Android是一个全新的东西, 所以说学起来并不是那么轻松. 两个星期的速成课每天都要接收大量的信息, 每天课后还有相应的实验需要完成. 尽管有点累, 总的来说还是很充实, 最后也顺利地和家祺完成了大作业的答辩. 而现在已经是八月的第二天了, 昨天去参加了字节跳动的Android实习的面试. 结果挺惨淡, 被面试官问得心里发毛. 回来后的感觉说不上来是失落还是什么, 毕竟本来也确实是抱着不管怎样去面一下总不亏的想法, 不过确实感觉心里梗梗的, 准确来说就是焦虑吧. 为什么会有这样的焦虑呢, 可能是因为理想与现实之间的巨大落差, 更可怕的是造成这种落差的根源就是自己. 回望这两年的大学生活, 除去那么几个时间点略微地为自己考虑和规划, 更多的是被推着迷茫地向前走. 对于专业课程, 大多只是流于表面, 而没有去深究. 现在想起来, 好像大学以来就没有细致地, 完整地读过任何一本书, 大多是人云亦云, 跟风从众, 三分热度, 半途而废. 老实说, 我是一个在自我管理方面做得很差的一个人, 特别是当没有一个明确的目标时, 往往会把大量的时间浪费在无意义的社交网络上, 窥探别人的生活, 荒废自己的日子. 现在是大二结束的暑假, 好像是时候为自己未来的人生做做规划了. Android是一个有趣的东西, 在开发Android的过程中, 既能体验到前端设计的美, 又能和后端通信满足一点点控制欲. 总听到种一棵树, 最好的时机是十年前, 其次是现在. 为了在这个学期结束后的寒假找到一份满意的实习, 大概需要掌握数据结构与算法, 数据库, 操作系统, 汇编语言, 计算机网络, Android开发, Java特性等等的技能, 再多了解Android的新技术, 类似于flutter, kotlin这样的. 接下来的日子里就在这个博客里记录我的计划和学习吧.]]></content>
      <tags>
        <tag>随便聊聊</tag>
      </tags>
  </entry>
</search>
