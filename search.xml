<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Graph Cut实现报告]]></title>
    <url>%2F2020%2F01%2F27%2FGraph-Cut%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1. 方法原理本实验的参考为: Boykov Y Y . Interactive graph cuts for optimal boundary &amp; region segmentation of objects in n-d images[C]// Proc. Eighth IEEE International Conference on Comput. Vis. ICCV 2001. IEEE Computer Society, 2001. 该实验实现了论文中的一个简化版本. 1.1 一些定义 $$A = (A_1, \ldots, A_p, \ldots, A_{|\mathcal{P}|})$$ $p$为图像$\mathcal{P}$上的一个像素点, $\mathcal{|P|}$为像素点的个数, $A$为一个二进制向量, $A_P$的取值为’obj’或’bkg’. 该向量定义了一个分割. $$E(A)=\lambda\cdot R(A) + B(A)$$ where $$R(A)=\sum_{p\in\mathcal{P}} R_p(A_p)$$ $$B(A)=\sum_{\{p,q\}\in\mathcal{N}} B_{\{p,q\}} \cdot \delta(A_p, A_q)$$ $$\delta(A_p, A_q)=\begin{cases} 1, &amp; \text{if $A_p\neq A_q$} \ 0, &amp; \text{otherwise.} \end{cases}$$ $E(A)$为能量函数 $\lambda$指定了区域项(region)属性$R(A)$和边界项(boundary)属性$B(A)$的相对重要性. $\lambda$越大则区域能量在总能量中所占的比重就越大，反之边界能量在总能量中所占比重越大。 $R(A)$给出了对将每个像素$p$赋值为$A_p$(‘obj’或’bkg’)的惩罚, 分别是$R_p(obj&quot;)\; or\; R_p(bkg”)$. 区域能量$R(A)$反映了将每一个像素$p$分割为$A_p$所花费的代价。若像素$p$与用户指定的背景像素越相似，则$R_p(bkg&quot;)$越小；若像素$p$与用户指定的前景像素越相似，则$R_p(obj”)$越小。 $B(A)$为分割$A$的边界能量. $B_{\{p, q\}} \geq 0$是对像素$p$和$q$之间不连续性的惩罚. 通常来说, 当像素$p$和$q$相似时, $B_{\{p, q\}}$很大; 当二者相差很大时, $B_{\{p, q\}}$接近于零. 一般地, 取$B_{\{p,q\}}=e^{-\beta|c_p-c_q|}$, $c_p, c_q$分别是像素$p,q$的颜色. 无向图$\mathcal{G = \langle V, E\rangle}$$$\mathcal{V = P}\bigcup {S,T}$$表示节点(verticals) $$\mathcal{E=N}\bigcup_{p\in\mathcal{P}}\{\{p,S\},\{p,T\}\}$$ 表示边(edges). n-link表示neighborhood links, t-link表示terminal-links. 每一条边 $\mathcal{e \in E}$都有自己的非负权重$w_e$. 我们要找的割是边的一个子集, $C\subset \mathcal{E}$, 使得两个终端被导出子图$\mathcal{G}(C)=\langle\mathcal{V}, \mathcal{E}\backslash C\rangle$所分离. 整个割的cost就是$$|C|=\sum_{e\in C} w_e$$ $\mathcal{O, B\subset P}$, 其分别代表物体像素集合和背景像素集合, $\mathcal{O\bigcap B = \emptyset}$ 下面给出各边的权重表 $$K=1+\max_{p\in\mathcal{P}}\sum_{q:\{p, q\}\in \mathcal{N}} B_{\{p,q\}}$$ 1.2 原理论文中证明, 图$\mathcal{G}$的最小切$\hat{C}$就对应于图像的最优分割, 这里不再赘述. 若${p, S}\in\hat{C}$, 则像素$p$分割为背景; 否则必然有${p, T}\in\hat{C}$, 则像素$p$分割为前景.那么graph cut就转化为了, 已知:$$A_p=\begin{cases} BKG, &amp; \text{if $p\in B$} \ OBJ, &amp; \text{if $p\in O$} \end{cases}$$求$$\min{E(A)=\lambda\cdot R(A) + B(A)}$$并进一步转化为求图的最小割的问题, 可用最大流最小割算法解决. 2. 代码描述2.1 运行环境 操作系统: Microsoft Windows 10专业版 1903 语言: Python 3.7.4 支持库: numpy 1.18.1 opencv-python 4.1.2.30 PyMaxflow 1.2.12 2.2 各模块及功能描述2.2.1 CommandLineMain模块用于用户启动及解析命令行参数的模块, 其中-i -o参数为必须参数, 分别为输入输出的图像地址. 2.2.2 InteractiveUI模块用于处理与用户交互有关的模块, 在原图的窗口上, 用户通过鼠标点击和滑动来选择OBJ_SEEDS和BKG_SEEDS, 按t切换鼠标点击选择的seeds种类, 按c清空现有seeds, 按g利用已选择的seeds对图像进行切割. 在关闭窗口的时候, 会自动保存已经生成的分割后的图像. 2.2.3 GraphBuilder模块 1def add_seed(self, x, y, seg_type) 利用用户在窗口上做的标记, 在全零覆盖seed_overlay加像素. BKG的标注为红色, OBJ的标注为绿色. 1def clear_seeds(self) 初始化前景和背景seeds数组, 以及覆盖seed_overlay. 1def init_graph_value(self) 将用户所添加的seeds转化为graph, 并进行初始化. 前景赋值为OBJ, 背景赋值为BKG. 1def finish_graph(self) 给每个像素一个一维编号, 并添加到nodes[]中, 且将背景连接到T, 前景连到S. 对每个像素(除去最右最下的), 将其与其右像素和下像素添加至edges[], 权重简化为两像素三通道差值平方和的倒数. 1def cut_graph(self) 运用PyMaxflow库, 将已有的图进行转化并求出其最小割, 将切割出来的前景部分标记为紫色. 3. 实验结果原图: 分割后图: 从实验结果上来看, 大致的分割时没有问题的. 但是由于权重取得比较粗糙, 并未像论文中那样, 所以导致边缘部分不够平滑, 且羽毛部分有丢失的情况产生. 用户可以通过现有分割, 适当添加seeds, 来达到分割效果更好的目的.]]></content>
      <tags>
        <tag>DIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode remote development配置]]></title>
    <url>%2F2020%2F01%2F21%2Fvscode-remote-development%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[因为最近需要用ssh在阿里云服务器上远程开发, 所以试一下vscode上的远程开发. 1. 安装扩展vscode安装Remote Development扩展, 剩下的Remote扩展可以自动安装. 2. 配置 安装OpenSSH, 理论上有git就行 1234567891011121314# 检测是否有适合安装的openssh软件Get-WindowsCapability -Online | ? Name -like &apos;OpenSSH*&apos;# 正常情况下返回# Name : OpenSSH.Client~~~~0.0.1.0# State : NotPresent# Name : OpenSSH.Server~~~~0.0.1.0# State : NotPresent# 安装openssh软件Add-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0# 正常情况下返回# Path :# Online : True# RestartNeeded : False Linux上需要安装ssh服务器, 需要支持用户名密码或密钥方式. 先确保用命令行能登录. 然后在vscode的settings.json中添加&quot;remote.SSH.showLoginTerminal&quot;: true 点左下角打开远程窗口按钮, 选择Remote-SSH: Connect to Host... -&gt; C:\Users\用户名\.ssh\config 粘贴下面的代码到打开的config文件, 到这一步就已经可以连接了, 但是要频繁输入密码. 12345Host TargetMachine # 目标机的ip地址 HostName 39.107.13.218 # 目标机的用户名 User root 3. 采用密钥认证避免频繁输入密码 如果之前用过github的ssh认证应该就能在C:\Users\用户名\.ssh里面看到id_rsa.pub文件, 复制一份到linux服务器上的~/.ssh/目录下. 如果之前没有使用过github的ssh认证, 在C:\Users\用户名\.ssh文件夹下打开powershell, 输入ssh-keygen, 一路回车下去, 就得到了这个文件. 把本地的id_rsa.pub文件复制到远端的~/.ssh下, 在该目录下执行cat id_rsa.pub &gt;&gt; authorized_keys, 实际上就是把内容加进去. 参考资料VSCode远程编辑,Remote-SSH,Remote Development VSCode Remote ssh跳板机配置（windows平台）]]></content>
      <tags>
        <tag>vscode</tag>
        <tag>remote development</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript学习笔记]]></title>
    <url>%2F2020%2F01%2F20%2Fjavascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这里只列出js与其他编程语言不一样的地方, 一样的则不再赘述. 对象方法 123456var object = &#123; method: function() &#123; &#125;&#125; 给尚未声明的变量赋值, 该变量自动作为window的一个属性. 1234567891011121314151617181920var var1 = 1; // 不可配置全局属性var2 = 2; // 没有使用 var 声明，可配置全局属性console.log(this.var1); // 1console.log(window.var1); // 1delete var1; // false 无法删除console.log(var1); //1delete var2; console.log(delete var2); // trueconsole.log(var2); // 已经删除 报错变量未定义//---------------carname是全局变量-----------// 此处可调用 carName 变量 function myFunction() &#123; carName = "Volvo"; // 此处可调用 carName 变量&#125; 返回对象名 123var x = 'abc';var y = new String("john");typeof x;l 相等switch中的case采用的是===s 1234//绝对相等var x = &quot;a&quot;;var y = new String(&quot;a&quot;);(x===y) //结果为false, 绝对相等属性和类型都要相等 js标签 1234567891011121314// label:// statementscars=["BMW","Volvo","Saab","Ford"];list: &#123; document.write(cars[0] + "&lt;br&gt;"); document.write(cars[1] + "&lt;br&gt;"); document.write(cars[2] + "&lt;br&gt;"); break list; document.write(cars[3] + "&lt;br&gt;"); document.write(cars[4] + "&lt;br&gt;"); document.write(cars[5] + "&lt;br&gt;"); &#125; null与undefined 12345678910111213var person = null; // 值为 null(空), 但类型为对象var person = undefined; // 值为 undefined, 类型为 undefinedvar person; // 值为 undefined(空), 类型是undefinedperson = undefined; // 值为 undefined, 类型是undefined//值相等但是类型不相等typeof undefined // undefinedtypeof null // objectnull === undefined // falsenull == undefined // true//先检测undefined, 再检测nullif (typeof myObj !== "undefined" &amp;&amp; myObj !== null) 正则表达式/正则表达式主题/修饰符(可选)修饰符: i: 执行对大小写不敏感的匹配. g: 执行全局匹配 m: 执行多行匹配 变量提升函数声明和变量声明总是会被解释器悄悄地被”提升”到方法体的最顶部。JavaScript 只有声明的变量会提升，初始化的不会。 严格模式不允许使用未声明的变量, 不允许删除变量或对象, 不允许删除函数, 不允许变量重名, 不允许使用八进制, 不允许使用转义字符, 不允许对只读属性赋值, 不允许对一个使用getter方法读取的属性进行复制, 不允许删除一个不允许删除的属性, 变量名不能用”eval”, “arguments”, 不允许this指向全局对象 1"use strict" //只在作用域内有效 表单验证 123456789function validateForm() &#123; var x = document.forms["myForm"]["fname"].value; if (x == null || x == "") &#123; alert("需要输入名字。"); return false; &#125;&#125;//可以用在onsubmit中 letlet声明的变量只在let命令所在的代码块内有效. javascript:void(0)void()代表不返回任何值, 但是括号里面的表达式还是会进行 内嵌函数与闭包 (解决计数器困境)所有函数都能访问全局变量。实际上，在 JavaScript 中，所有函数都能访问它们上一层的作用域。JavaScript 支持嵌套函数。嵌套函数可以访问上一层的函数变量。 12345678910111213141516var add =function () &#123; var counter = 0; window.alert("父方法"); // 只有在 add 赋值时执行一次 return function () &#123; window.alert("子方法"); // 每次执行 add() 都会执行 return counter += 1; &#125; // counter 作用域在父函数中, 自然在其子函数中也能使用,但因为 // 子函数还需要使用了count, 所以 count 不随着父函数一起释放。 // 利用在 function()&#123;&#125;() 的形式自动执行一遍父匿名函数, 赋给 add 子方法。&#125;();function myFunction()&#123; document.getElementById("demo").innerHTML = add(); //这里add()执行的就是子方法&#125; JavaScript HTML DOM(Document Object Model)EventListener, 监听事件.addEventListener() 方法添加的事件句柄不会覆盖已存在的事件句柄。可以向一个元素添加多个事件句柄。可以向同个元素添加多个同类型的事件句柄，如：两个 “click” 事件。可以向任何 DOM 对象添加事件监听，不仅仅是 HTML 元素。如： window 对象。addEventListener() 方法可以更简单的控制事件（冒泡与捕获）。当使用 addEventListener() 方法时, JavaScript 从 HTML 标记中分离开来，可读性更强， 在没有控制HTML标记时也可以添加事件监听。可以使用 removeEventListener() 方法来移除事件的监听。 事件冒泡或事件捕获事件传递有两种方式：冒泡与捕获。事件传递定义了元素事件触发的顺序。 如果你将 元素插入到 元素中，用户点击 元素, 哪个元素的 “click” 事件先被触发呢？在冒泡中，内部元素的事件会先被触发，然后再触发外部元素，即： 元素的点击事件先触发，然后会触发 元素的点击事件。在捕获中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即： 元素的点击事件先触发 ，然后再触发 元素的点击事件。addEventListener() 方法可以指定 “useCapture” 参数来设置传递类型：false为冒泡传递, true为捕获传递. BOM浏览器对象模型(Browser Objdect Model) Window对象表示浏览器窗口, 包括HTML DOM的document也是window对象的属性之一: window.document.getElementById(&quot;header&quot;)计时事件 1234window.setInterval(function, milliseconds)window.clearInterval(intervalVariable)window.setTimeout(function, milliseconds)window.clearTimeout(timeoutVariable) CookieCookie用于存储web页面的用户信息.Cookie以键值对的形式存储, username = John Doe1234567891011121314151617181920212223242526272829303132function setCookie(cname,cvalue,exdays)&#123; var d = new Date(); d.setTime(d.getTime()+(exdays*24*60*60*1000)); var expires = "expires="+d.toGMTString(); document.cookie = cname + "=" + cvalue + "; " + expires;&#125;function getCookie(cname)&#123; var name = cname + "="; var ca = document.cookie.split(';'); for(var i=0; i&lt;ca.length; i++) &#123; var c = ca[i].trim(); if (c.indexOf(name)==0) return c.substring(name.length,c.length); &#125; return "";&#125;function checkCookie()&#123; var user=getCookie("username"); if (user!="")&#123; alert("欢迎 " + user + " 再次访问"); &#125; else &#123; user = prompt("请输入你的名字:",""); if (user!="" &amp;&amp; user!=null)&#123; setCookie("username",user,30); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CO 汉明码]]></title>
    <url>%2F2019%2F10%2F26%2FCO-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E5%8F%8A%E6%A3%80%E9%94%99%E7%BA%A0%E9%94%99%2F</url>
    <content type="text"><![CDATA[假定有一个长为k位的数据, 要另外添加r个校验位来保证k+r中任何一个数据位出错时, 将影响r个校验位中不同的校验位组合起变化, 此外还需要一个组合来反映正确的情况. 故位数r和k的关系为:$$2^r\geq k+r+1$$汉明码的码距(即从一个合法码变成另一个合法码至少要改变几位码的值)为4. 可以发现并改正一位错, 能发现两位错(但不能改正). 如何为各校验位分配数据位组合(假定$k=3,r=4$):$$P1(1), P2(2), D1(3), P3(4), D2(5), D3(6), P4$$ 看数据位编号分别为3, 5, 6, 他们均可表示为校验位编号的组合: $$3=1+2, 5=1+4, 6=2+4$$ 1出现在3和5中, 则校验位P1需要对D1和D2进行校验. 2出现在3和6中, 则校验位P2需要对D1和D3进行校验. 4出现在5和6中, 则校验位P3需要对D2和D3进行校验. 最后用其他各校验位及各数据位进行异或运算求P4的值, 用于区分无错, 奇数位错, 偶数位错三种情况.$\mathrm{P4=P3\bigoplus P2\bigoplus P1\bigoplus D3\bigoplus D2\bigoplus D1}$]]></content>
      <tags>
        <tag>Notes</tag>
        <tag>Computer Organization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章 引论]]></title>
    <url>%2F2019%2F10%2F10%2F%E7%AC%AC1%E7%AB%A0-%E5%BC%95%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[用户与操作系统交互的程序, 基于文本的通常称为shell, 而基于图标的则称为图形用户界面(Graphical User Interface), 它们实际上并不是操作系统的一部分. 多数计算机有两种运行模式: 内核态和用户态. 软件中最基础的部分是操作系统, 它运行在内核态(也称为管态, 核心态). 在内核态中, 操作系统具有对所有硬件的完全访问权, 可以执行机器能够运行的任何指令. 软件的其余部分运行再用户态下. 在用户态下, 只使用了机器指令的一个子集. 用户接口程序(shell或者GUI)处于用户态程序中的最低层次, 允许用户运行其他程序(Web浏览器等). 操作系统运行再裸机之上, 为所有其他软件提供基础的运行环境. 什么是操作系统操作系统有两个基本上独立的任务, 即为应用程序员(实际上是应用程序)提供一个资源集的清晰抽象, 并管理这些硬件资源. 下面逐项进行讨论操作系统的功能. 作为扩展机器的操作系统多数计算机的体系结构(指令集, 存储组织, I/O和总线结构)是很原始的, 而且编程时很困难的. 操作系统的任务就是创建好的抽象, 并实现和管理它所创建的抽象对象. 作为资源管理者的操作系统自顶向下地看, 操作系统向应用程序提供基本抽象. 按照自底向上的观点, 操作系统则用来管理一个复杂系统的各个部分, 其任务是在相互竞争的程序之间有序地控制对处理器, 存储器以及其他I/O接口设备的分配. 资源管理包括用一下两种不同方式实现多路复用(共享)资源: 在时间上复用和在控件上复用.]]></content>
      <categories>
        <category>Modern Operating System</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中秋]]></title>
    <url>%2F2019%2F09%2F13%2F%E4%B8%AD%E7%A7%8B%2F</url>
    <content type="text"><![CDATA[现在是2019年中秋最开始的一个小时. 四个小时前, 我, H和Z说趁着小学期结束去喝两杯. 我想记录下来, 希望五年或者十年后还能记得这几个王八蛋酒友. 我和Z君上学期倒是有出来喝过, 最开始在酒吧, 凌晨十二点半, 酒吧许是看着没啥生意, 说要打烊了. 于是我和Z君提着两打燕京在学服门口喝到五点, 期间还绕着学校走了一圈, 最后把阿姨叫醒放我们回去睡大觉, 现在想起来还觉得怪不好意思. 说起Z君, 虽说一直也相处得挺好, 不过倒是第一次约出来作酒友. 说老实话, Z君和H君那些关于爱情的往事我基本上也知道得八九不离十, 都有过那么些个不堪回首的经历. 总的来说, Z君是痴情男儿, 对远在土澳的那个人念念不忘(或许现在已经慢慢释然), 按他自己的话来说已经无力再爱; H君前几天刚与心结say goodbye, 嘴上说着已经释怀, 但我总觉着还得过一阵子; 而我自己, 早就说过不敢再奢望, 但即使不用看的, 也能嗅到来源于她的特殊味道. 兄弟少年, 都是那么贱兮兮的. 说起未来, Z君已经联系好导师, 不出意外应该能保上本校的研究生(我觉得Z君应该有更好的出路, 不过这也是后话了). H君和我准备着实习, 大四毕业找工作. 我们谈着至少也得在北京这座城市里奋斗那么五年十年, 还约好谁发文章, 谁拿工资得请请吃饭, 对未来既充满了踌躇有满怀期望, 虽然矛盾但却是当下最真实的想法, 毕竟已经过了大一最迷茫的时刻. 明天, 不, 今天就是中秋节了. 想起初中高中那会儿, 中秋节还会到湘江边上, 要么到茶摊蹭大人们点的菊花茶, 要么从小贩那买一盏孔明灯点上, 让它承载着我的期望, 随风而去. 离家千万里的现在, 幸好还有亲人在. 不出意外, 十二个小时后应该会和姐姐出去吃顿饭, 说起来, 我们上半年基本没怎么见过, 尽管就在同一个城市. 或许是因为北京城太大, 或许是因为我们之间的差异太大. 另外妈妈也会过来, 该用什么样的心情去面对呢? 随机应变吧, 这事不值得费脑子. 晚安.]]></content>
      <tags>
        <tag>随便聊聊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-09]]></title>
    <url>%2F2019%2F09%2F05%2F2019-09%2F</url>
    <content type="text"><![CDATA[九月份已经过去五天了, 之前因为小学期的关系, 没时间腾出来想一想这个月该干的事情. 先回顾一下上个月. 说好的看计算机网络的内容, 实际上还是摸鱼了, 只看了第一章. (要是没有摸鱼, 说不定小学期就不会过得这么艰难了, 哭) 算法和数据结构以及LeetCode的题感觉完成度有个50%? 嘛, 反正这是一个长期项目, 每个月根据所看的内容写个几十道困难题, 我觉得也还行. 然后到了九月份的计划.先暂时列一个书单吧: 计算机网络自顶向下方法 现代操作系统 算法(S&amp;W) 汇编语言 如果有英文版本就中英对照着看, 不过为了能快速阅读, 还是以中文版本为主吧.]]></content>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小学期即时聊天软件后]]></title>
    <url>%2F2019%2F09%2F05%2F%E5%B0%8F%E5%AD%A6%E6%9C%9F%E5%8D%B3%E6%97%B6%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6%E5%90%8E%2F</url>
    <content type="text"><![CDATA[记录一下在做完小学期聊天软件项目之后, 得到的一些感触. 学习能力方面仍然欠缺太多。 在没有接触过多线程和网络编程的情况下去，我发现我学习socket编程的速度确实过慢。导致后来放弃做网络通信模块，转而做数据库模块。好在有之前数据库知识的储备，虽然也是第一次用mysql，但是无论是上手还是设计接口都来得得心应手。这算是比较满意的一个部分。 设计对于程序的重要性甚至超过编码。 就我个人编写的数据库模块而言，在我第一天初步设计好所有数据库供服务端调用的接口之后，我和吴大伟在第二天实现接口时，几乎是一气呵成，其中还包括了各个接口的简单测试。而且第一天实现好了接口，也方便服务端先调用空的接口，实现大致的代码框架。 团队合作能力的重要性。 在项目的最开始，我们便决定了使用github托管项目进行版本控制，但由于基本上大家之前要么没用过git，要么只用github托管过个人项目，不需要团队合作，也就不会有那么多的代码冲突。在我们实际的项目进行中，虽然这种情况不常见，但还是出现了版本诸如回退之后删除了本地未提交文件等错误。再就是合码真的是一个累活，既要保证自己的代码不出现问题，还要保证别人在调用的时候传入正确的参数，最后还需要自己编写的模块能使整个项目正常运转，我们合码的时间确实是过晚了，如果能重来的话，我想我会选择写一部分合一部分测一部分，而不是各个模块先分工，最后大家每个模块都完成得差不多了再进行代码的整合。 英语能力的欠缺。 对于一般的库来说，中文文档基本不能保证是最新的版本，且代码质量和代码风格也得不到保证，机翻又会导致有些专有词汇错翻。倒不是说看不懂英文文档，只是看英文文档时速度实在是太慢，只适合于看看某个函数的大致功能是啥，传入啥参数什么的。除开文档外，想要得到一些优质的问题解决方案，StackOverflow是必不可少的，基本对我来说，上StackOverflow最多看看回答者的回答，而回答下面的跟答就很少看了，总的来说还是英文能力太弱了。]]></content>
      <tags>
        <tag>随便聊聊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell命令基础]]></title>
    <url>%2F2019%2F08%2F27%2Fshell%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[小学期需要在linux环境下完成即使通讯软件, 因此需要懂一点shell的基础知识. 随手做笔记~希望里面不要出现纰漏. Base&lt;用户名&gt;@&lt;主机名&gt;:~(用户主目录, 即/home/&lt;用户名&gt;)$(#代表root用户)命令基本格式 command [option] [arguments] 查询操作:man info –help Command ls -a 显示所有 -l 详细信息 -X 按扩展名的字典序排列 -x 按行 -C 按列 -d 本目录 ls &gt; a.txt &gt; 为重定向符 即将ls得到的结果写入a.txt mvmv [1] [2]文件改名文件移到目标文件夹下文件夹移到目标文件夹下文件夹改名 cpcp [文件] [目录]cp -a [目录] [目录] (所有属性都不变)cp -r [目录] [目录] (递归拷贝, 不保留文件属性(例如文件创建时间)) mkdirmkdir -p [目录] 嵌套创建目录mkdir -m&lt;权限&gt; [目录] 权限设置例如: mkdir -m777 dir, 在当前目录下创建了一个权限为777, 文件名为dir的目录 rmrm [文件]rm -r [目录] filefile [目标文件或目录] 确定文件类型 cat/tac -n 显示行号 cat [文件1] [文件2] 合并之后展示, 不生成新的文件 cat [文件1] [文件2] &gt; [文件3] 将文件1,2合并后写入文件3 touchtouch [文件名] 创建文件 ln -s 软链接: 类似于快捷方式, 用于指向原来的文件. 删除软连接, 不影响原来的文件; 删除原文件, 软连接则不可再使用 硬链接: 默认创建硬链接, 相当于原文件的一个别名, 实际上是同一个文件. 举个栗子: 创建a.txt, 写入hello, 为a.txt创建软链接s.txt和硬链接r.txt, 删除a.txt, s.txt无法使用, r.txt仍然是hello, 重新创建a.txt, 写入world, 此时s.txt内容为world, r.txt仍为hello. 可见, 软链接靠文件名访问. tar(打包和压缩不是同一个概念) -c 创建tar文件 -f 将文件打包生成到一个文件里 如:tar -cf new.tar /home/junqi -x 对tar进行解包 tar -xf new.tar .bz2和.gz的区别: 1. .bz2比.gz压缩率更高 2. .gz比.bz2花费更少的时间 针对zip格式: 1. 打包 tar cvzf &lt;文件名&gt;.gz &lt;目录&gt; 将目录下的文件打包并压缩 2. 解包 tar xvzf &lt;文件名&gt;.gz 解压到当前目录; tar xvzf &lt;文件名&gt;.gz -C &lt;目录&gt; 解包到制定的目录下 针对biz2: 1. 打包 tar cvjf &lt;文件名&gt;.biz2 &lt;目录&gt; 将目录下的文件打包并压缩 2. 解包 tar xvjf &lt;文件名&gt;.biz2 解压到当前目录; tar xvjf &lt;文件名&gt;.biz2 -C &lt;目录&gt; 解包到制定的目录下]]></content>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#316 去除重复字母]]></title>
    <url>%2F2019%2F08%2F24%2FLeetCode-316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D%2F</url>
    <content type="text"><![CDATA[题面解:思路:总的想法是, 尽量让字典序小的字母靠前出现. 对于字符串cbacdcbc进行遍历, 在已经选择的串为c的情况下考虑第二个字母b, 因为后面仍然有c, 且b的字典序比c小, 删掉现有的c并将b加入选择的串, 这样得到的结果更优(同一个位置字典序小的字母占优, 不论后面的字母如何变幻). 第三个字母同理. 遍历到第四个和第五个字母时, 字典序呈升序, 直接加入结果仍然最优. 遍历第六个字母c时, 因为选择结果中已经出现过c, 所以不做处理(如果需要做处理, 那么就要删除已选择的元素直到至少把之前的那个c删除才能保证字典序不变大. 如果恰好删除到之前的c, 再加入现在的c, 这样的操作就毫无意义. 如果删除了更之前的, 即类似将a替换成了c, 仍然使字典序变大了). 再到b, 未出现过, 直接加入. 用StringBuilder代替栈, 方便最后转成字符串. 算法: 初始化int[] count数组, 初始化boolean[] used数组, 初始化存放结果的StringBuilder resSb和LinkedList resList 遍历一遍字符串, 记录每个字母出现的次数, count[s.charAt(i) - &#39;a&#39;]++ 遍历字符串, char letter作为当前字符, i为当前索引值. count[letter - &#39;a&#39;]-- 如果当前字符已经出现在sb中, 即used[letter - &#39;a&#39;] == true, continue. 当已选择的字串不为空resList.size() &gt; 0, 该字符的字典序小于栈顶的字符letter &lt; resList.getLast(), 且栈顶字符在字符串的后面仍然会出现count[resList.getLast() - &#39;a&#39;] &gt; 0 更新used[resList.getLast() - &#39;a&#39;] = false 弹出栈顶, resList.removeLast() 循环 添加当前字母, resList.addLast(letter), used[letter - &#39;a&#39;] = true. 遍历resList, 依次添加入resSb, 返回resSb.toString()代码:1234567891011121314151617181920212223242526272829public String removeDuplicateLetters(String s) &#123; int[] count = new int[26]; boolean[] used = new boolean[26]; StringBuilder resSb = new StringBuilder(); LinkedList&lt;Character&gt; resList = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; count[s.charAt(i) - 'a']++; &#125; char letter; for (int i = 0; i &lt; s.length(); i++) &#123; letter = s.charAt(i); count[letter - 'a']--; if (used[letter - 'a']) &#123; continue; &#125; while (resList.size() &gt; 0 &amp;&amp; letter &lt; resList.getLast() &amp;&amp; count[resList.getLast() - 'a'] &gt; 0) &#123; used[resList.getLast() - 'a'] = false; resList.removeLast(); &#125; resList.addLast(letter); used[letter - 'a'] = true; &#125; for (Character character : resList) &#123; resSb.append(character); &#125; return resSb.toString();&#125; 复杂度: 执行用时 内存消耗 语言 12ms(51.42%) 35.7MB(66.07%) Java 时间复杂度 $ O(n) $ 空间复杂度 $ O(n) $]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#232 用栈实现队列]]></title>
    <url>%2F2019%2F08%2F24%2FLeetCode-232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题面两个栈实现:思路:用一个栈作为队列尾, 另一个栈作为队列头. 形如: 算法: 入队直接压入rear 出队如果front不为空直接出front栈顶, 如果front为空, 将rear元素全部转移到front再出front栈顶. 为空判断两个栈是否都为空 队首与出队类似 代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MyQueue &#123; Stack&lt;Integer&gt; front; Stack&lt;Integer&gt; rear; /** Initialize your data structure here. */ public MyQueue() &#123; front = new Stack&lt;&gt;(); rear = new Stack&lt;&gt;(); &#125; /** Push element x to the back of queue. */ public void push(int x) &#123; rear.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ public int pop() &#123; if (empty()) &#123; throw new RuntimeException("QueueEmpty"); &#125; if (front.empty()) &#123; while (!rear.empty()) &#123; front.push(rear.pop()); &#125; &#125; return front.pop(); &#125; /** Get the front element. */ public int peek() &#123; if (empty()) &#123; throw new RuntimeException("QueueEmpty"); &#125; if (front.empty()) &#123; while (!rear.empty()) &#123; front.push(rear.pop()); &#125; &#125; return front.peek(); &#125; /** Returns whether the queue is empty. */ public boolean empty() &#123; return front.empty() &amp;&amp; rear.empty(); &#125;&#125; 复杂度: 执行用时 内存消耗 语言 83ms(90.67%) 35MB(43.88%) Java 时间复杂度: 分摊下来为$ O(1) $, 对于任意$n$个元素的入队和出队来说, 其操作总次数都不会超过$4n$次, 即每个元素都入队列且都出队(相当于每个元素都入rear栈, 出rear栈, 进front栈, 再出front栈). 但对于某一次的出队操作来说, 其时间复杂度会出现$ O(n) $的情况. 空间复杂度 $ O(n) $, 需要两个栈存元素.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#85 最大矩形]]></title>
    <url>%2F2019%2F08%2F20%2FLeetCode-85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[题面运用栈:思路:为方便讨论, 假定矩阵的层数从上往下依次递增. 假定最大矩形的底边在第n层, 对于第n层中为”0”的那些列, 对最大矩形无贡献. 对于第n层中为”1”的那些列, 最大矩形的高度为某一个”1”往上的连续个”1”之和. 遍历矩阵的层, 对每层按LeetCode#84 柱状图中最大的矩形的算法求出对应的面积. 要求的最大面积为这n层所求面积中最大的那个. 算法: 初始化高度数组heights[matrix.length][matrix[0].length], maxArea = 0 按层遍历matrix, 对于矩阵的每层, 更新相应的heights[i][] 按照LeetCode#84 柱状图中最大的矩形中的算法传入高度数组, 更新maxArea 代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445public int maximalRectangle(char[][] matrix) &#123; if (matrix == null || matrix.length == 0) &#123; return 0; &#125; int maxArea = 0; int[][] heights = new int[matrix.length][matrix[0].length]; for (int i = 0; i &lt; heights.length; i++) &#123; for (int j = 0; j &lt; heights[0].length; j++) &#123; if (i == 0) &#123; heights[i][j] = matrix[i][j] == '0' ? 0 : 1; &#125; else &#123; heights[i][j] = matrix[i][j] == '0' ? 0 : heights[i - 1][j] + 1; &#125; &#125; &#125; for (int[] height : heights) &#123; maxArea = Math.max(maxArea, maxHistogramRectangle(height)); &#125; return maxArea; &#125;static private int maxHistogramRectangle(int[] heights) &#123; int maxArea = 0; Stack&lt;Integer&gt; heightsIndexStack = new Stack&lt;&gt;(); heightsIndexStack.push(-1); for (int i = 0; i &lt; heights.length; i++) &#123; while (heightsIndexStack.peek() != -1 &amp;&amp; heights[i] &lt;= heights[heightsIndexStack.peek()]) &#123; int mid = heightsIndexStack.pop(); int width = i - heightsIndexStack.peek() - 1; maxArea = Math.max(maxArea, heights[mid] * width); &#125; heightsIndexStack.push(i); &#125; while (heightsIndexStack.peek() != -1) &#123; int mid = heightsIndexStack.pop(); int width = heights.length - heightsIndexStack.peek() - 1; maxArea = Math.max(maxArea, heights[mid] * width); &#125; return maxArea;&#125; 复杂度: 执行用时 内存消耗 语言 54ms(27.98%) 49.3MB(45.00%) Java 假定矩阵为$ m \times n $矩阵 时间复杂度 $ O(m*n) $, 计算heights[][]需要$ O(m * n) $; 遍历层数, 对每层求最大面积需要$ O(m * n) $. 空间复杂度 $ O(m*n) $, 存放高度的heights[][]需要$ O(m * n) $; 栈需要$ O(n) $.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#84 柱状图中最大的矩形]]></title>
    <url>%2F2019%2F08%2F19%2FLeetCode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[题面 暴力解:思路:对于每个出现的柱子高度, 找到该高度对应的最大面积.对于高度2, 1, 5, 6, 2, 3, 出现了1, 2, 3, 5, 6五个高度. 我们只需遍历一遍这五个高度, 找出每个高度对应的连续的高大于等于该高度的柱子数即可. 算法: 创建HashSet, 对高度进行去重. 以height遍历HashSet中每一个高度 初始化maxWidth = 0, width = 0 遍历原柱子数组 如果当前高度大于height, width++. 否则, maxWidth = Math.max(maxWidth, width), width = 0. 再次更新maxWidth, 以比较最后一串连续的柱子宽和maxWidth. 更新最大面积maxArea 代码:12345678910111213141516171819202122232425static public int largestRectangleArea(int[] heights) &#123; int maxArea = 0; HashSet&lt;Integer&gt; heightSet = new HashSet&lt;&gt;(); for (int height : heights) &#123; heightSet.add(height); &#125; for (Integer height : heightSet) &#123; int maxWidth = 0; int width = 0; for (int currentHeight : heights) &#123; if (currentHeight &gt;= height) &#123; width++; &#125; else &#123; maxWidth = Math.max(maxWidth, width); width = 0; &#125; &#125; maxWidth = Math.max(maxWidth, width); maxArea = Math.max(maxArea, maxWidth * height); &#125; return maxArea;&#125; 复杂度: 执行用时 内存消耗 语言 708ms(18.85%) 44.3MB(20.35%) Java 时间复杂度 $ O(n^2) $, 最坏情况, 当所有柱子高度都不同, 且依次递增时, 内外循环次数都为n 空间复杂度 $ O(n) $, HashSet占用额外$ O(n) $ 空间复杂度为$ O(n^2) $时, 会爆内存. 应用单调栈思路:遍历每个柱子, 对每个柱子而言, 他所能达到的最大面积为, 最小高度为该柱子的高度, 宽度最宽的矩形. 即对于每个柱子, 要找到他左右两边第一个小于他的柱子, 中间形成的矩形的面积便是该柱子所能达到的最大面积. 这样的思路和LeetCode#42 接雨水就很像了, 考虑运用单调栈解决问题. 考虑一排递增的柱子, 每个柱子的左边第一个便是第一个小于他的柱子. 我们用栈来维护这样一个递增的序列. 遍历所有柱子, 如果当前柱子的高度大于等于栈顶柱子的高度, 则直接压栈; 否则, 当前柱子便是现在的栈顶柱子的右边第一个小于他的柱子, 将当前柱子记作right, 弹出栈顶元素记作mid, 弹出后的新栈顶便是mid左边第一个小于他的柱子, 记作left, 这样便可以求出以heights[mid]为高度, 介于left和right之间的矩形面积最大值. 算法: 初始化栈heightIndexStack, 压入-1(索引-1可作为任意右边柱子的左边界); 初始化最大面积maxArea = 0 遍历所有柱子, 当前遍历到的柱子索引记作current 如果栈不为空(即栈顶元素不为-1)且当前柱子的高度小于等于栈顶柱子的高度(如果去掉等于, 假定一组高度为1, 1, 2, 2, 1, 那么当读到最后一个1时, 栈内为-1, 0, 1, 2, 3, 显然当索引3作为中间值的时候, 索引2并不能成为其左边界). 弹出栈顶元素, 记作mid 以heights[mid]为高度的最大矩形区域的宽为width = current - heightIndexStack.peek() - 1 更新maxArea = Math.max(maxArea, heights[mid] * width) 将当前柱子索引压栈 若此时栈仍然不为空(即栈顶元素不为-1), 相当于current移动到heights.length的位置, 继续更新maxArea直到栈空代码:1234567891011121314151617181920212223242526static public int largestRectangleArea(int[] heights) &#123; if (heights == null || heights.length == 0) &#123; return 0; &#125; int maxArea = 0; Stack&lt;Integer&gt; heightIndexStack = new Stack&lt;&gt;(); heightIndexStack.push(-1); for (int current = 0; current &lt; heights.length; current++) &#123; while (heightIndexStack.peek() != -1 &amp;&amp; heights[current] &lt;= heights[heightIndexStack.peek()]) &#123; int mid = heightIndexStack.pop(); int width = current - heightIndexStack.peek() - 1; maxArea = Math.max(maxArea, width * heights[mid]); &#125; heightIndexStack.push(current); &#125; while (heightIndexStack.peek() != -1) &#123; int mid = heightIndexStack.pop(); int width = heights.length - heightIndexStack.peek() - 1; maxArea = Math.max(maxArea, width * heights[mid]); &#125; return maxArea;&#125; 复杂度: 执行用时 内存消耗 语言 44ms(42.76%) 43.1MB(34.64%) Java 时间复杂度 $ O(n) $, 每个元素入栈出栈两次操作. 空间复杂度 $ O(n) $, 栈需要额外的$ O(n) $空间.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Stack</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#42 接雨水]]></title>
    <url>%2F2019%2F08%2F17%2FLeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[题面 暴力解:思路:对于每个元素, 其能达到的最大高度为该元素左边所有元素中的最大值和右边所有元素中的最大值其中较小的那一个. 算法: 初始化res为0 便利整个height数组 初始化 leftMax = height[left], rightMax = height[right] 从当前元素向左扫描并更新leftMax 从当前元素向右扫描并更新rightMax 当左右最大元素值均比当前元素值大时, res += Math.min(leftMax, rightMax) - height[i]; 代码:1234567891011121314151617181920212223242526static public int trap(int[] height) &#123; int res = 0; for (int i = 1; i &lt; height.length - 1; i++) &#123; int left = i - 1, right = i + 1; int leftMax = height[left]; int rightMax = height[right]; while (left &gt;= 0) &#123; if (leftMax &lt; height[left]) &#123; leftMax = height[left]; &#125; left--; &#125; while (right &lt;= height.length - 1) &#123; if (rightMax &lt; height[right]) &#123; rightMax = height[right]; &#125; right++; &#125; if (height[i] &lt; leftMax &amp;&amp; height[i] &lt; rightMax) &#123; res += Math.min(leftMax, rightMax) - height[i]; &#125; &#125; return res;&#125; 复杂度: 执行用时 内存消耗 语言 152ms(5.4%) 42MB(60.13%) Java 时间复杂度 $ O(n) $, 对于每个元素, 都要从扫描整个数组 空间复杂度 $ O(1) $ 应用栈:思路:遍历数组时, 用栈来追踪可能储水的长条或作为”墙”的长条. 储水长条和”墙”长条的概念是相对的, 可以变动. 有水坑的必要条件是当前扫描到的长条作为”墙”长条, 栈中至少有一个储水长条和一个”墙”长条, 这样即可填平”一层”(“一层”的高可能超过1, 这里指的是一层或多层宽度相同的方块条叠起来). 层层填平后, 当前位置之前的所有水坑已填平(当作后面已经没有长条). 当前长条将作为新的储水长条或”墙”长条压入栈. 当前长条的高度小于栈顶高度时, 将当前长条压入栈.当前长条的高度大于或等于栈顶长条的高度时, 层层填平两个长条中间的部分, 并将当前长条压入栈. 算法: 使用栈stack来保存长条的索引 遍历数组 当栈不为空且当前元素的高度大于或等于栈顶元素的高度 弹出栈顶元素topIndex. 若栈为空(意味着之前的坑全部填平, 且无论怎么填后面的坑都不会对之前的坑有影响), 跳出循环. 计算要填的”一层”坑的宽度: trapWidth = current - stack.peek() - 1, 高度: trapHeight = Math.min(height[current], height[stack.peek()]) - height(topIndex). 填坑, res += trapWidth * trapHeight. 重复以上操作. 将当前元素压入栈 图示: 代码:123456789101112131415161718static public int trap(int[] height) &#123; int res = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int current = 0; current &lt; height.length; current++) &#123; while (!stack.empty() &amp;&amp; height[current] &gt;= height[stack.peek()]) &#123; int topIndex = stack.pop(); if (stack.empty()) &#123; break; &#125; int trapWidth = current - stack.peek() - 1; int trapHeight = Math.min(height[current], height[stack.peek()]) - height[topIndex]; res += trapWidth * trapHeight; &#125; stack.push(current); &#125; return res;&#125; 复杂度: 执行用时 内存消耗 语言 15ms(19.33%) 37.1MB(85.67%) Java 时间复杂度 $ O(n) $, 每个条形快最多访问两次, 即压入和弹出操作$ O(1) $. 空间复杂度 $ O(n) $, 栈最多占用$ O(n) $的空间]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Homework Problems and Questions Chapter1]]></title>
    <url>%2F2019%2F08%2F11%2FHomework-Problems-and-Questions-Chapter1%2F</url>
    <content type="text"><![CDATA[Review QuestionsSECTION 1.1 没有区别; 手机, PC, iPad, 服务器, 智能家居终端; 算. A protocol is a rule which describes how an activity should be performed, especially in the field of diplomacy. In diplomatic services and governmental fields of endeavor protocols are often unwritten guidelines. Protocols specify the proper and generally accepted behavior in matters of state and diplomacy. 开发者可以根据协议标准开发可以互相通信的网络系统, 标准不同则无法通信. SECTION 1.2 Class Access Technologies Home Access DSL Internet Access, Cable Internet Access, FTTH, Satellite access, Dial-up access, WiFi Enterprise Access 100 Mbps Ethernet, WiFi. Wide-area Wireless Access 3G, 4G, 5G HFC 带宽是用户间共享的. 下行通道是共享的, 每个分组由单一的头端发送向下行径每段链路到每个家庭, 藉由分布式多路访问协议可避免碰撞. Access Technologies Upstream Rate Downstream Rate Monthly Price FTTH 20 Mbps 200 Mbps 60元 4G 7.72 Mbps 38.2 Mbps 17元 使用以太网接入, 用户通常以100Mbps速率接入以太网交换机, 而服务器可能具有1Gbps甚至10Gbps的接入速率. 绝大部分是双绞铜线, 也能运行在光纤上. Access Technologies Transmission Rates Bandwidth DSL 55 Mbps downstream and 15 Mbps upstream dedicated HFC up to 42.8 Mbps downstream and 30.7 Mbps upstream shared FTTH 2-10 Mbps upload; 10-20 Mbps download shared Dial up 56 kbps dedicated WiFi 和 4G 技术:a) 在无线LAN环境中, 无线用户必须位于接入点几十米范围内发送或接收分组. 传输速率高达54Mbps. 接入点一般连接着有线因特网, 将无线用户接入有线网络.b) 分组通过蜂窝网提供商运营的基站来发送和接受, 一个用户只需位于基站的数万米内. SECTION 1.3 0时刻发送主机开始发送, $ t_1 = L / R_1 $ 时刻发送主机完成发送, 由于没有传播时延, 同时刻整个分组被路由器接收, 并同时由路由器开始发送向接收主机. $ t_2 = t_1 + L / R_2 $时刻, 路由器发送完分组, 整个分组被接收主机接收. 所以端对端时延为$ L / R_1 + L / R_2 $. 电路交换网络在端系统通信会话期间, 预留了端系统间通信沿路径所需的资源(缓存, 链路传输速率). 绝大部分的分组交换网络不能保证端对端通信的带宽. 频分复用需要复杂的模拟硬件来讲信号转换到合适的频带. a. $ 2 / 1 = 1 $b. 在发送时, 每个用户需要1 Mbps, 如果两个或更少的用户同时传输, 最多需要2 Mbps. 共享链路的带宽是2 Mbps, 所以不会有排队时延. 当有3个及以上的用户同时发送时, 他们需要3 Mbps或更多, 带宽无法满足, 于是存在排队时延.c. $ 0.2 $d. 三个用户同时发送数据的概率为 $ 0.2^3 $, 只有当三个用户同时发送数据时, 队列才会增长, 故队列增长的时间比例也是 $ 0.2^3 $. 如果同等级的ISP不对等的话, 相互通信则需要向提供商ISP支付流量成本. IXP可以向连接着他的ISP收取费用. 谷歌的专用网络连接起了它所有的数据中心. 谷歌的数据中心之间的流量通过其专用网络传输, 而不是公共因特网. 谷歌的数据中心直接与低级别的ISP连接, 所以当谷歌向用户提供内容时, 可以绕过更高级别的ISP; 首先, 因为它使用很少的中间ISP, 所以内容提供商可以提供更好的用户体验. 其次, 它可以向提供商网络发送更少的流量节省费用. SECTION 1.4 处理时延, 排队时延, 传输时延, 传播时延. 除了排队时延, 其他的都是确定的. Transmission vs Propagation Delaya. $1000km, 10^8m/s, 1Mbps, 100Bytes$b. $10km, 2.9\times10^8m/s, 1Mbps, 100Bytes$ $t = \frac{2500km}{2.5\cdot10^8m/s} = 10ms$, $ d/s $, no, no. a. 500 kbpsb. 64sc. 320s 如何生成分组: 将文件分块 在每个块前加上header形成分组 每个分组包含目的地的IP地址 分组交换器如何将分组转发到对应的链路: 分组交换其识别分组中的IP地址来确定转发的链路. 比喻: 车比作分组, 拿着目的地地址问路比作分组交换器识别分组中的IP地址并转发分组到相应的链路. Queuing and Loss最大的发送速率: 200 packets/minute最小的传输速率: 1 packets/minute流量强度为200当发送的过程相同时, 两次的初始丢包时间相同. SECTION 1.5 error control, flow control, segmentation and reassembly, multiplexing, and connection setup; yes. the application layer, the transport layer, the network layer, the link layer, the physical layer.Principal responsibilities:Application layer: HTTP, SMTP, and FTP protocols are used in application layer. it is used to send data over multiple end systems. Transport layer: Transfer the content between two endpoints mainly. TCP and UDP protocols are used in transport layer. Network layer: Move the packets between any two hosts in the network. IP protocol is used in network layer. Data link layer: Move the packets from one node to the next another node. Point-to-point protocol (ppp) used in data link layer. Physical layer: Transfer the individual bits from one node to the next node with in the frame. 应用层报文: 应用程序想要发送并传递到传输层的数据运输层报文段: 封装了应用层应用层报文和传输层标头网络层数据报: 封装了运输层报文段和网络层标头链路层帧: 封装了网络层数据报和链路层标头 网络层, 链路层, 物理层; 链路层, 物理层; 五层都处理 SECTION 1.6 病毒需要与人交互才能传播. 蠕虫可以自己扫描IP地址和端口号, 寻找可以注入的进程 创造僵尸网络: 攻击者寻找有漏洞的主机系统 用木马破坏主机系统用于DDoS: 僵尸网络中的任何系统都可以利用漏洞自动扫描环境并传播 创造僵尸网络的人可以远程控制僵尸网络中的所有节点 攻击者可以命令僵尸网络中的所有节点向某个节点攻击 Problems]]></content>
      <categories>
        <category>Computer Networking A Top-Down Approach(7th Edition) RQ&amp;P</category>
      </categories>
      <tags>
        <tag>Computer Networks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter1 Computer Networks and the Internet]]></title>
    <url>%2F2019%2F08%2F04%2FChapter1-Computer-Networks-and-the-Internet%2F</url>
    <content type="text"><![CDATA[What Is the InternetA Nuts-and-Bolts DescriptionThe Internet is a computer network that interconnects billions of computing devices throughout the world. All of these devices are called hosts or end systems. End systems are connected together by a network of communication links and packet switches. Transmission rate is measured in bits/second. When one end system has data to send to another end system, the sending end system segments the data and adds header bytes to each segment. The resulting packages of information is known as packets. The two most prominent types in today’s Internet are routers and link-layer switches. The sequence of communication links and packet switches traversed by a packet from the sending end system to the receiving end system is known as a route or path through the network. End systems access the Internet through Internet Service Providers (ISPs). Protocols control the sending and receiving of information within the Internet. The Transmission Control Protocol(TCP) and the Internet Control Protocol(TCP) are two of the most important protocols in the Internet. Internet standards are developed by the Internet Engineering Task Force(IETF). The IETF standards documents are called request for comments(RFCs). A Services DescriptionThe applications that Internet provides services to are said to be distributed applications, since they involve multiple end systems that exchange data with each other. Socket interface specifies how a program running on one end system asks the Internet infrastructure to deliver data to a specific destination program running on another end system. What Is a Protocol?A protocol defines the format and the order of messages exchanged between two or more communicating entities, as well as the actions taken on the transmission and/or receipt of a message or other event. The Network EdgeHosts are sometimes further divided into two categories: clients and servers. Access Networks The access network is the network that physically connects and end system to the first router(also known as the “edge router”). Home AccessToday, the two most prevalent types of broadband residential access are digital subscriber line(DSL) and cable. For the DSL Internet access, the residential telephone line carries both data and traditional telephone signals simultaneously, which are encoded at different frequencies: A high-speed downstream channel, in the 50 kHz to 1 MHz band A medium-speed upstream channel, in the 4 kHz to 50 kHz band An ordinary two-way telephone channel, in the 0 to 4 kHz band The DSL standards define multiple transmission rates, including 55 Mbps downstream and 15 Mbps upstream[ITU 2006]. The access is said to be asymmetric. One important characteristic of cable Internet access is that it is a shared broadcast medium. In particular, every packet sent by the head end travels downstream on every link to every home and every packet sent by a home travels on the upstream channel to the head end. While DSL makes use of telco’s existing local telephone infrastructure, cable Internet access makes use of the cable television company’s existing cable television infrastructure. The cable Internet access is typically asymmetric, with downstream channel typically allocated a higher transmission rate than the upstream channel. The DOCSIS 2.0 standard defines downstream rates up to 42.8 Mbps and upstream rates of up to 30.7 Mbps. An up-and-coming technology that provides even higher speeds is fiber to the home(FTTH). The FTTP concept is simple–provide an optical fiber path from the CO directly to the home. This image shows FTTH using the passive optical network(PON) distribution architecture. Each home has an optical network terminator(ONT), which is connected by dedicated optical fiber to a neighborhood splitter. The splitter combines a number of homes onto a single, shared optical fiber, which connects to an optical line terminator(OLT) in the telco’s CO. The OLT, providing conversion between optical and electrical signals, connects to the Internet via a teleco router. In locations where DSL, cable, and FTTH are not available, a satellite link can be used to connect a residence to the Internet at speeds of more than 1 Mbps. Dial-up access over traditional phone lines is based on the same model as DSL–a home modem connects over a phone line to a modem in the ISP. Dial-up access is excruciatingly slow at 56 kbps. Access in the Enterprise (and the Home): Ethernet and WiFi On corporate and university campuses, and increasingly in home settings, a local area network(LAN) is used to connect an end system to the edge router. Ethernet is by far the most prevalent access technology in many types of LAN technologies. With Ethernet access, users typically have 100 Mbps or 1 Gbps access to the Ethernet switch, whereas servers may have 1 Gbps or even 10 Gbps access. Wireless LAN access based on IEEE 802.11 technology, more colloquially known as WiFi, is now everywhere. 802.11 today provides a shared transmission rate of up to more than 100 Mbps. Wide-Area Wireless Access: 3G and LTEDevices like smartphones employ the same wireless infrastructure used for cellular telephony to send/receive packets through a base station that is operated by the cellular network provider. Physical MediaFor each transmitter-receiver pair, a bit is sent by propagating electromagnetic waves or optical pulses across a physical medium. Physical medium fall into two categories: guided media and unguided media. With guided media, the waves are guided along a solid medium, such as a fiber-optic cable, a twisted-pair copper wire, or a coaxial cable. With unguided media, the waves propagate in the atmosphere and in outer space, such as in a wireless LAN or a digital satellite channel. Twisted-Pair Copper WireThe least expensive and most commonly used guided transmission medium. Unshielded twisted pair(UTP) is commonly used for computer networks within a building, that is, for LANs. Data rates for LANs using twisted pair today range from 10 Mbps to 10 Gbps, which depend on the thickness of the wire and the distance between transmitter and receiver. Coaxial CableLike twisted pair coaxial cable consists of two copper conductors, but the two conductors are concentric rather than parallel, which can make coaxial cable achieve high data transmission rates. Coaxial cable can be used as a guided shared medium. Fiber OpticsAn optical fiber is a thin, flexible medium that conducts pulses of light, with each pulse representing a bit. A single optical fiber can support tremendous bit rates, up to tens of even hundreds of gigabits per second. They are immune to electromagnetic interference. Terrestrial Radio ChannelsThey require no physical wire to be installed. Satellite Radio ChannelsThe communication satellite receives transmissions on one frequency band, regenerates the signal using a repeater, and transmits the signal on another frequency. The Network Core Packet SwitchingIn a network application, end systems exchange messages with each other.To send message from a source end system to a destination end system, the source breaks long messages into smaller chunks of data known as packets. Between source and destination, each packet travels through communication links and packet switches(two predominant types, routers and link-layer switches). Store-and-Forward TransmissionMost packet switches use store-and-forward transmission at the inputs to the links. It means that the packet switch must receive the entire packet before it can begin to transmit the first bit of the packet onto the outbound link. Queuing Delays and Packet LossEach packet switch has multiple links attached to it. For each attached link, the packet switch has an output buffer(also called an output queue), which stores packets that the router is about to send into the link. Due to this, packets suffer output buffer queuing delays. When an arriving packet find that the buffer is completely full with other packets waiting for transmission, packet loss will occur–either the arriving packet or one of the already-queued packets will be dropped. Forwarding Tables and Routing ProtocolsIn the Internet, every end system has an address called an IP address. A packet source includes the destination’s IP address in the packet’s header. Each router has a forwarding table that maps destination addresses(or portions of the destination addresses) to that router’s outbound links. The Internet has a number of special routing protocols that are used to automatically set the forwarding tables. A routing protocol may, for example, determine the shortest path from each router to each destination and use the shortest path results to configure the forwarding tables in the routers. Circuit SwitchingThere are two fundamental approaches to moving data through a network of links and switches: circuit switching and packet switching. In circuit-switched networks, the resources(buffers, link transmission rate) needed along a path to provide for communication between the end systems are reserved for the duration of the communication session between the end systems. In packet-switched networks, these resources are not reserved. Consider the traditional telephone networks, the network must establish a connection between the sender and the receiver. The switches on the path between the sender and receiver maintain connection state for that connection. This connection is called a circuit. Multiplexing in Circuit-Switched NetworksA circuit in a link is implemented with either frequency-division multiplexing(FDM) or time-division multiplexing(TDM). With FDM, the frequency spectrum of a link is divided up among the connections established across the link. The link dedicates a frequency band to each connection for the duration of the connection. The width of the band is called bandwidth. For a TDM link, time is divided into frames of fixed duration, and each frame is divided into a fixed number of time slots. These slots are dedicated for the sole use of that connection. Packet Switching Versus Circuit SwitchingPacket switching has end-to-end delays is variable and unpredictable.(due primarily to variable and unpredictable queuing delays) But it offers better sharing of transmission capacity than circuit switching and it is simpler, more efficient, and less costly to implement than circuit switching. Circuit switching pre-allocates use of the transmission link regardless of demand, with allocated but unneeded link time going unused. Packet switching on the other hand allocates link use on demand. A Network of NetworksBy creating a network of networks, the puzzle, the access ISPs themselves must be interconnected is completed. A points of presence(PoP) is simply group of one or more routers(at the same location) in the provider’s network where customer ISPs can connect into the provider IPS. PoPs exist in all levels of the hierarchy, except for the bottom(access ISP) level. For a customer network to connect to a provider’s PoP, it can lease a high-speed link from a third-party telecommunications provider to directly connect one of its routers to a router at the PoP. Any ISP(except for tier-1 ISPs) may choose to multi-home, that is, to connect to two or more provider ISPs. To reduce the costs that a customer ISP pays a provider ISP for amount of traffic, a pair of nearby ISPs at the same level of the hierarchy can peer. They can directly connect their networks together so that all the traffic between them passes over the direct connection rather than through upstream intermediaries. Along these same lines, a third-party company can create an Internet Exchange Point(IXP), which is a meeting point where multiple ISPs can peer together. Content provider, like Google, can created its own networks and connect directly into lower-tier ISPs(settlement free) where possible. Delay, Loss, and Throughput in Packet-Switched Networks.Computer networks necessarily constrain throughput(the amount of data per second that can be transferred) between end systems, introduce delays between end systems, and can actually lose packets. Overview of Delay in Packet-Switched NetworksThe most important delays are the nodal processing delay, queuing delay, transmission delay, and propagation delay; together, these delays accumulate to give a total nodal delay. Processing DelayThe time required to examine the packet’s header and determine where to direct the packet is part of the processing delay. Processing delays in the high-speed routers are typically on the order of microseconds or less. Queuing DelayAt the queue, the packet experiences a queuing delay as it waits to be transmitted onto the link. Queuing delays can be on the order of microseconds to milliseconds in practice. Transmission DelayDenote the length of the packet by $ L $ bits, and denote the transmission rate of the link from router A to router B by $ R $ bits/sec. The transmission delay is $ L/R $. This is the amount of time required to push(that is, transmit) all of the packet’s bits into the link. Transmission delays are typically on the order of microseconds to milliseconds in practice. Propagation DelayOnce a bit is pushed into the link, it needs to propagate to router B. The time required to propagate from the beginning of the link to router B is the propagation delay. The propagation speed depends on the physical medium of the link(that is, fiber optics, twisted-pair copper wire, and so on) and is in the range of $ 2 \times 10^8 $ meters/sec to $ 3 \times 10^8 $ meters/sec. The propagation delay is the distance between two routers divided by the propagation speed. In wide-area networks, propagation delays are on the order of milliseconds. Comparing Transmission and Propagation DelayThe transmission delay is the amount of time required for the router to push out the packet; it has nothing to do with the distance between the two routers. The propagation delay is the time it takes a bit to propagate from one router to the next; it is a function of the distance between the two routers, but has nothing to do with the packet’s length or the transmission rate of the link. Queuing Delay and Packet LossThe most complicated and interesting component of nodal delay is the queuing delay. The rate at which traffic arrives at the queue, the transmission rate of the link, and the nature of the arriving traffic, that is whether the traffic arrives periodically or arrives in bursts, impacts the queuing delay. Let $ a $ packets/sec denote the average rate at which packets arrive at the queue. $ R $ bits/sec is the transmission rate. All packets consist of $ L $ bits. Then the average rate at which bits arrive at the queue is $ La $ bits/sec. The ratio $ La/R $, called traffic intensity, often plays an important role in estimating the extent of the queuing delay. One of the golden rules in traffic engineering is: Design your system so that the traffic intensity is no greater than 1. Consider the case $ La/R \leq 1 $. Here, the nature of the arriving traffic impacts the queuing delay. Typically, the arrival process to a queue is random. Packet LossIn reality a queue preceding a link has finite capacity. Packet delays do not really approach infinity as the traffic intensity approaches 1. Instead, a packet can arrive to find a full queue. With no place to store such a packet, a router will drop the packet; that is, the packet will be lost. Therefore, performance at a node is often measured not only in terms of delay, but also in terms of the probability of packet loss. End-to-End delaySuppose there are $ N-1 $ routers between the source host and the destination host. $ d_{proc} $ is the processing delay at each router and at the source host. The transmission rate out of each router and out of the source host is $ R $ bits/sec, and the propagation on each link is $ d_{prop} $. The nodal delays accumulate and give an end-to-end delay, $$ d_{end-end} = N(d_{proc} + d_{trans} + d_{prop}) $$, where, $ d_{trans} = L/R $, where $ L $ is the packet size. Throughput in Computer NetworksIn addition to delay and packet loss, another critical performance measure in computer networks is end-to-end throughput. The instantaneous throughput at any instant of time is the rate (in bits/sec) at which Host B is receiving the file from Host A. For some applications, including those involving file transfers, delay is not critical, but it is desirable to have the highest possible throughput. The constraining factor for throughput in today’s Internet is typically the access network because the core of the Internet is over-provisioned with high speed links that experience little congestion. When there is no other intervening traffic, the throughput for a file transfer is the transmission rate of the bottleneck link along the path between server and client. More generally, the throughput depends not only on the transmission rates of the links along the path, but also on the intervening traffic. Protocol Layers and Their Service ModelsFor organizing a network architecture, or at least our discussion of network architecture. Layered ArchitectureEach layer provides its service by (1) performing certain actions within that layer and by (2) using the services of the layer directly below it. For large and complex systems that constantly being updated, the ability to change the implementation of a service without affecting other components of the system is another important advantage of layering. Protocol LayeringTo provide structure to the design of network protocols, network designers organize protocols–and the network hardware and software that implement the protocols–in layers. The service model of a layer: Each layer provides its service by (1) performing certain actions within that layer and by (2) using the services of the layer directly below it. For example, the services provided by layer n may include reliable delivery of messages from one edge of the network to the other. This might be implemented by using an unreliable edge-to-edge message delivery service of layer n-1, and adding layer n functionality to detect and retransmit lost. A protocol layer can be implemented in software, in hardware, or in a combination of the two. Layering provides a structured way to discuss system components. Modularity makes it easier to update system components. One potential drawback of layering is that one layer may duplicate lower-layer functionality. A second potential drawback is that functionality at one layer may need information that is present only in another layer. When taken together, the protocols of the various layers are called the protocol stack. Application LayerThe application layer is where network applications and their application-layer protocols reside. Protocols in the Internet’s application layer Function HTTP provide for Web document request and transfer SMTP provide for the transfer of e-mail messages FTP provide for the transfer of files between two end systems An application-layer protocol is distributed over multiple end systems, with the application in one end system using the protocol to exchange packets of information with the application in another end system. We’ll refer to the packet of information at the application layer as a message. Transport LayerThe Internet’s transports layer transports application-layer messages between application endpoints. Each of TCP and UDP can transport application-layer messages. TCP provides a connection-oriented service to its applications. This service include guaranteed delivery of application-layer messages to the destination and flow control(that is, sender/receiver speed matching). TCP breaks long messages into shorter segments and provides a congestion-control mechanism, so that a source throttles its transmission rate when the network is congested. The UDP protocol provides a connectionless service to its applications. This is a no-frills service that provides no reliability, no flow control, and no congestion control. We’ll refer to a transport-layer packet as a segment. Network LayerThe Internet’s network layer is responsible for moving network-layer packets known as datagrams from on host to another. The Internet transport-layer protocol(TCP or UDP) in a source host passes a transport-layer segment and a destination address to the network layer. The network layer then provides the service of delivering the segment to the transport layer in the destination host. The Internet’s network layer includes the IP protocol, which defines the fields in the datagram as well as how the end systems and routers act on these fields. The Internet’s network layer also contains routing protocols that determine the routes that datagram take between sources and destinations. Link LayerTo move a packet from one node(host or router) to the next node in the route, the network layer relies on the services of the link layer. Examples of link-layer protocols include Ethernet, WiFi, and the cable access network’s DOCSIS protocol. We’ll refer to the link-layer packets as frames. Physical LayerThe job of the physical layer is to move the individual bits within the frame from one node to the next. The protocols in this layer depends on the actual transmission medium of the link. For example, Ethernet has many physical-layer protocols: one for twisted-pair copper wire, another for coaxial cable, another for fiber, and so on. The OSI ModelThe Internet protocol stack is not the only protocol stack around. In the late 1970s, the International Organization for Standardization(ISO) proposed that computer networks be organized around seven layers, called the Open Systems Interconnection(OSI) model. The role of the presentation layer is to provide services that allow communicating applications to interpret the meaning of data exchanges. These services include data compression and data encryption(which are self-explanatory) as well as data description(which frees the applications from having to worry about the internal format in which data are represented/stored–formats that may differ from one computer to another). The session layer provides for delimiting and synchronization of data exchange. including the means to build a checkpointing and recovery schema. Encapsulation The figure shows the physical path that data takes down a sending end system’s protocol stack, up and down the protocol stacks of an intervening link-layer switch and router, and then up the protocol stack at the receiving end system. The figure also illustrates the importance concept of encapsulation. At the sending host, an application-layer message($ M $) is passed to the transport layer. The transport layer takes the message and appends additional information(transport-layer header information, $ H_t $) that will be used by the receiver-side transport layer. The application0layer message and the transport-layer header information together constitute the transport-layer segment. The transport-layer segment thus encapsulates the application-layer message. The added information might include information allowing the receiver-side transport layer to deliver message up to the appropriate application, and error-detection bits that allow the receiver to determine whether bits in the message have been changed in route. The transport layer then passes the segment to the network layer, which adds network-layer header information($ H_n $) such as source and destination end system address, creating a network-layer datagram. The link layer will add its own link-layer header information and create a link-layer frame. At each layer a packet has two types of fields: header fields and a payload field.]]></content>
      <categories>
        <category>Computer Networking A Top-Down Approach(7th Edition)</category>
      </categories>
      <tags>
        <tag>Computer Networks</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-08]]></title>
    <url>%2F2019%2F08%2F02%2F2019-08%2F</url>
    <content type="text"><![CDATA[这个月主要是呆在学校里面, 自己自学, 目标是Algorithms, 4th Edition by Robert Sedgewick和Computer Networking A Top-Down Approach, 7th Edition, 中间再穿插写leetcode. 重新看算法的目的一是重温一下数据结构和算法的基础知识, 以便刷leetcode题的时候不至于到处爬博客现学, 二是为了好好练练自己的Java代码的编写质量. 计网是新东西, 这本书好像同样也是用Java实现. 刷leetcode的题是为了将来在面试的时候不至于手足无措, 然后同时也是和詹蛋蛋约好的相互监督. 对于所学的东西, 我尽量以博客的形式把他们记录下来, 相当于是做了笔记. 这篇文章主要起一个索引的作用, 也将实时更新. 计算机网络 有用的笔记Chapter1 Computer Networks and the Internet 课后练习Homework Problems and Questions Chapter1 LeetCode算法与数据结构 习题&amp;例子]]></content>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我为什么这么焦虑]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E7%84%A6%E8%99%91%2F</url>
    <content type="text"><![CDATA[在期末考试之前的那段日子里得知字节跳动要和学校联合搞一个Android的暑期课程, 本着闲着也是闲着的心态填了报名表. 训练从7月11号开始, 一直持续到8月22号. 对于我而言, Android是一个全新的东西, 所以说学起来并不是那么轻松. 两个星期的速成课每天都要接收大量的信息, 每天课后还有相应的实验需要完成. 尽管有点累, 总的来说还是很充实, 最后也顺利地和家祺完成了大作业的答辩. 而现在已经是八月的第二天了, 昨天去参加了字节跳动的Android实习的面试. 结果挺惨淡, 被面试官问得心里发毛. 回来后的感觉说不上来是失落还是什么, 毕竟本来也确实是抱着不管怎样去面一下总不亏的想法, 不过确实感觉心里梗梗的, 准确来说就是焦虑吧. 为什么会有这样的焦虑呢, 可能是因为理想与现实之间的巨大落差, 更可怕的是造成这种落差的根源就是自己. 回望这两年的大学生活, 除去那么几个时间点略微地为自己考虑和规划, 更多的是被推着迷茫地向前走. 对于专业课程, 大多只是流于表面, 而没有去深究. 现在想起来, 好像大学以来就没有细致地, 完整地读过任何一本书, 大多是人云亦云, 跟风从众, 三分热度, 半途而废. 老实说, 我是一个在自我管理方面做得很差的一个人, 特别是当没有一个明确的目标时, 往往会把大量的时间浪费在无意义的社交网络上, 窥探别人的生活, 荒废自己的日子. 现在是大二结束的暑假, 好像是时候为自己未来的人生做做规划了. Android是一个有趣的东西, 在开发Android的过程中, 既能体验到前端设计的美, 又能和后端通信满足一点点控制欲. 总听到种一棵树, 最好的时机是十年前, 其次是现在. 为了在这个学期结束后的寒假找到一份满意的实习, 大概需要掌握数据结构与算法, 数据库, 操作系统, 汇编语言, 计算机网络, Android开发, Java特性等等的技能, 再多了解Android的新技术, 类似于flutter, kotlin这样的. 接下来的日子里就在这个博客里记录我的计划和学习吧.]]></content>
      <tags>
        <tag>随便聊聊</tag>
      </tags>
  </entry>
</search>
